<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kingrong&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/5c9b0550374b2b8d9a9118de88f5b71a</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.kingr.top/"/>
  <updated>2019-09-14T14:06:11.264Z</updated>
  <id>http://www.kingr.top/</id>
  
  <author>
    <name>Kingrong</name>
    <email>Kingronghuang@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust 错误处理探索</title>
    <link href="http://www.kingr.top/2019/09/12/rust-error-handle/"/>
    <id>http://www.kingr.top/2019/09/12/rust-error-handle/</id>
    <published>2019-09-12T02:12:59.000Z</published>
    <updated>2019-09-14T14:06:11.264Z</updated>
    
    <content type="html"><![CDATA[<p>从JavaScript，从Java，从Python甚至是从C过来，都会不习惯<em>Rust</em>的错误处理方式。但这不是rust限制了你错误处理的方式。事实上rust提供了很大的自由度来进行错误处理，灵活的方式。</p><p>对于Rust来说，<code>Option</code>和<code>Result</code>很大程度上造成了你在错误处理上的不适感。</p><p>要熟练地使用这些方式并不简单，但当你熟练之后，你应当会十分地enjoy这个过程。</p><p>这篇博客简单记录了一下我最近遇到的错误处理的方式。<br><a id="more"></a></p><h2 id="简单处理"><a href="#简单处理" class="headerlink" title="简单处理"></a>简单处理</h2><ul><li><code>unwrap()</code></li><li><code>expect()</code></li></ul><p>对我来说，最为直接而简单的处理<code>Option</code>和<code>Result</code>的方式就是<code>unwarp()</code>，这种方式给你一种在其他语言中编程的体验，但是总是使用这种方式并不是很好的选择。如果你并不能确定你的代码会得到什么样的结果，那么最好不要在生产环境中使用这种方式。</p><p>但是有一些时候我们可以毫不犹豫地使用这种方式——但是确定这是什么结果的时候。比如说：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> regex::Regex;</span><br><span class="line"><span class="keyword">let</span> gender_re = Regex::new(<span class="string">r"input\[name='sexs'\]\[value='(.+?)'\]"</span>).unwrap();</span><br></pre></td></tr></table></figure><p>另外我觉得也可以在项目开发和测试过程中使用<code>unwrap()</code>或者<code>expect</code>来处理，来快速看看结果是否符合预期以及获得一些简单的提示。</p><h2 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h2><ul><li><code>ok_or()</code>和<code>map_err()</code></li><li><code>dyn std::error::Error</code></li><li><code>?</code>运算符</li><li>新建错误类型和包装错误</li></ul><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>我非常喜欢像<code>ok_or</code>、<code>map_err</code>等的方式，来转换错误。</p><ul><li><code>ok_or()</code>将<code>Option&lt;T&gt;</code>转换为<code>Result&lt;T, Err&gt;</code>。</li><li><code>map_err()</code>将<code>Result&lt;T, E&gt;</code> 转换为<code>Result&lt;T, F&gt;</code>，即转换为另一个错误类型。</li></ul><p>这两种方式结合自定义错误和<code>?</code>运算符以及自定义的错误可以写出非常简洁的代码。很多时候我们并不喜欢写大段的<code>match</code>，虽然我们很喜欢<code>match</code>语法。</p><p><code>dyn std::error::Error</code> 方式很强大，你给任何一个实现了<code>std::error::Error</code> <em>trait</em>的错误，它都照单全收。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_fn</span></span>(param: <span class="built_in">Result</span>&lt;&amp;<span class="built_in">str</span>, &amp;<span class="built_in">str</span>&gt;) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;dyn std::error::Error&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> param &#123;</span><br><span class="line">        <span class="literal">Ok</span>(n) =&gt; n.parse::&lt;<span class="built_in">i32</span>&gt;()?,</span><br><span class="line">        <span class="literal">Err</span>(_e) =&gt; <span class="literal">Ok</span>(<span class="number">0</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个错误的过程十分明了：</p><ul><li>定义错误</li><li>实现<code>std::fmt::Display</code> trait</li><li>实现<code>std::error::Error</code> trait</li><li>如果需要实现包装错误，实现<code>From</code>trait</li></ul><p>详见<a href="https://doc.rust-lang.org/rust-by-example/error/multiple_error_types/define_error_type.html" target="_blank" rel="noopener">Define an error type</a></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>以下代码是我最近一次使用<code>reqwest</code>模拟登录中获取cookie的代码（网址非真实网址）。</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_cookie</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, LoginError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> url = <span class="string">"http://www.example.com/example"</span>;</span><br><span class="line">    <span class="keyword">let</span> resp = Client::new().get(url)</span><br><span class="line">        .header(USER_AGENT, <span class="string">"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.131 Safari/537.36"</span>)</span><br><span class="line">        .send().map_err(reqwest_result_handle)?;</span><br><span class="line">    <span class="keyword">let</span> set_cookie = resp.headers().get(SET_COOKIE).ok_or(LoginError::NoSetCookie)?; </span><br><span class="line">    <span class="keyword">let</span> set_cookie = (set_cookie.to_str().map_err(|_e| LoginError::Other)?).to_string();</span><br><span class="line">    <span class="keyword">let</span> re = Regex::new(<span class="string">r"PHPSESSID=([\w\d]+?);.*"</span>);</span><br><span class="line">    <span class="keyword">let</span> re_result = re.unwrap().captures(&amp;set_cookie).ok_or(LoginError::NoSessId)?;</span><br><span class="line">    <span class="literal">Ok</span>(re_result[<span class="number">1</span>].to_string())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>LoginError</code>是自定义的一个错误枚举，<code>reqwest_result_handle</code>是一个将<em>reqwest</em>的错误转换为<code>LoginError</code>的一个函数。以上我总共用了两次<code>map_err()</code>和两次<code>ok_or()</code>，<code>map_err</code>用来将我在使用<em>reqwest</em>过程中遇到的<code>Error</code>转换为我自定义的<code>LoginError</code>，并使用<code>?</code>直接返回，节省了许多代码；<code>ok_or</code>两次都用在返回的结果是<code>Option&lt;T&gt;</code>的时候，我们不希望草率的用<code>unwrap()</code>来完成这样一个操作，我们新建了两个不同的错误来接受不存在的结果，并使用<code>?</code>直接返回。</p><p>以上两者如果全程使用<code>match</code>语法来操作，那有可能会是一个mess的火葬场，不信你试试。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://doc.rust-lang.org/rust-by-example/error/multiple_error_types/define_error_type.html" target="_blank" rel="noopener">Define Error Type</a></li><li><a href="https://doc.rust-lang.org/rust-by-example/error/multiple_error_types/boxing_errors.html" target="_blank" rel="noopener">Boxing Errors</a></li><li><a href="https://doc.rust-lang.org/rust-by-example/error/multiple_error_types/wrap_error.html" target="_blank" rel="noopener">Wrapping Errors</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从JavaScript，从Java，从Python甚至是从C过来，都会不习惯&lt;em&gt;Rust&lt;/em&gt;的错误处理方式。但这不是rust限制了你错误处理的方式。事实上rust提供了很大的自由度来进行错误处理，灵活的方式。&lt;/p&gt;
&lt;p&gt;对于Rust来说，&lt;code&gt;Option&lt;/code&gt;和&lt;code&gt;Result&lt;/code&gt;很大程度上造成了你在错误处理上的不适感。&lt;/p&gt;
&lt;p&gt;要熟练地使用这些方式并不简单，但当你熟练之后，你应当会十分地enjoy这个过程。&lt;/p&gt;
&lt;p&gt;这篇博客简单记录了一下我最近遇到的错误处理的方式。&lt;br&gt;
    
    </summary>
    
      <category term="Rust" scheme="http://www.kingr.top/categories/Rust/"/>
    
    
      <category term="rust" scheme="http://www.kingr.top/tags/rust/"/>
    
      <category term="error handle" scheme="http://www.kingr.top/tags/error-handle/"/>
    
  </entry>
  
  <entry>
    <title>编程语言中的异步IO模型</title>
    <link href="http://www.kingr.top/2019/09/09/async-models/"/>
    <id>http://www.kingr.top/2019/09/09/async-models/</id>
    <published>2019-09-09T05:44:39.000Z</published>
    <updated>2019-09-09T14:08:18.926Z</updated>
    
    <content type="html"><![CDATA[<p>在看先前的拉丁美洲的Rustconf，偶然看到了<em>Without Boats</em>大佬的关于零成本异步IO的介绍。</p><p>在其中学习到一些异步编程模型，在此做一个总结。 </p><p>视频链接：<a href="https://youtu.be/skos4B5x7qE?list=PL85XCvVPmGQjuWUNeFCgl8X2EOC_aAq5N" target="_blank" rel="noopener">Without Boats: Zero-Cost Async IO</a></p><iframe width="889" height="500" src="https://www.youtube.com/embed/skos4B5x7qE?list=PL85XCvVPmGQjuWUNeFCgl8X2EOC_aAq5N" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><a id="more"></a><h2 id="零成本抽象"><a href="#零成本抽象" class="headerlink" title="零成本抽象"></a>零成本抽象</h2><blockquote><p>What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.</p></blockquote><p>这是<em>Without Boats</em>在视频里对零成本抽象的介绍。这是由C++发展过来的好东西。我主要有一下两点理解（好吧，就是简单的翻译（逃。。）：</p><ul><li>对于你用不上的东西，它不会对你的程序性能产生影响</li><li>对于需要用上的东西，你不能找到更好的方式使性能更佳</li></ul><p>提出这个定义的人提出了一个很棒的东西。</p><h2 id="语言中的异步编程模型"><a href="#语言中的异步编程模型" class="headerlink" title="语言中的异步编程模型"></a>语言中的异步编程模型</h2><p>每一种异步IO模型都有相应的典型语言的。</p><h3 id="绿色线程模型"><a href="#绿色线程模型" class="headerlink" title="绿色线程模型"></a>绿色线程模型</h3><p>首先介绍绿色线程，这在rust官网的<em>The Book</em>的无畏并发中有设计。Rust官方库中的线程模型是对应的就是OS的线程模型，即1:1，一个OS线程对应的就是一个编程语言的线程，这样换来了Rust中相较于其他编程语言的更小的运行时，意味着更小的开销。不同的编程语言可能有不同的特殊的线程模型，可能是<code>M</code>个绿色线程对应<code>N</code>个OS线程。所以绿色线程就是不同于OS线程的编程语言中的自己的线程实现。</p><p>使用绿色线程来实现异步编程的语言中实现异步的方式就是新创建一个绿色线程，然后在这个绿色线程中执行异步IO代码。</p><p>使用绿色线程实现异步IO的语言有：Java和Go</p><p>这个方式很棒，但是这个方式不属于零成本抽象的范畴。原因是：这个方式需要在语言层面的Runtime增加去调度绿色线程的代码，这意味着即便你的用户不需要用到异步IO功能，他还是需要为此付出代价。</p><h3 id="Future-模型（基于回调）"><a href="#Future-模型（基于回调）" class="headerlink" title="Future 模型（基于回调）"></a><strong>Future</strong> 模型（基于回调）</h3><p>一个<em>future</em>代表着一个还没有准备好的值。</p><p><em>future</em>在JavaScript中有另一个名字<code>Promise</code>，熟悉JavaScript的同学对这个关键词应该不陌生。在JavaScript中我们给每一个Promise都设置一个回调（resolve, reject）。当我们的Promise准备好的时候，会去调用resolve中的代码或者是reject中的代码。这种方式是非常棒的方式。</p><p>在ES2017，JavaScript的作者们将<code>async</code>和<code>await</code>语法实现到了JavaScript中，这简直极大的方便了我们去编写异步的代码。</p><p>通过以上的JavaScript的<code>Promise</code>实现。我们可以知道：</p><ol><li>使用回调方式的<code>Future</code>模型</li><li><code>Future</code>模型可以实现为<code>async</code>和<code>await</code>语法</li></ol><p>这个方式也非常Amazing，但是这种方式同样不属于零成本抽象的范畴。原因是：使用回调的方式并不是使性能最佳的方式，他还可以有更好的实现。</p><h3 id="Rust的异步模型（基于Poll）"><a href="#Rust的异步模型（基于Poll）" class="headerlink" title="Rust的异步模型（基于Poll）"></a><em>Rust</em>的异步模型（基于Poll）</h3><p>基于回调的<code>Future</code>模型大抵是这样的：<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Future</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">schedule</span></span>&lt;F&gt;(<span class="keyword">self</span>, callback: F)</span><br><span class="line">    <span class="keyword">where</span> F: <span class="built_in">FnOnce</span>(Self::Output);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>基于Poll的<code>Future</code>模型大约长这样：<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Future</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, waker: &amp;Waker) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Poll</span></span> &#123;</span><br><span class="line">    Ready&lt;T&gt;,</span><br><span class="line">    Pending,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>观察这两者的区别，我们发现基于回调的模型，我们需要在它有返回值之前就给它设置好一个callback，回调函数；而基于Poll的模型，只是返回一个包含数据的枚举，表示自己准备好了（Ready<t>），还是没有准备好（Pending）。</t></p><p>基于Poll的<code>Future</code>模型，给了用户更多的灵活性，但同时意味着，用户必须要做更多的事情。比如，你如果想要得到结果就立即执行相关的代码，你就必须时刻在轮询<code>poll</code>这个函数，当它返回Ready时，对相关的数据（T）执行相关的代码。多数时候你不能在主要的线程中执行轮询，所以我们可能需要一个可以管理绿色线程的运行时，比如说<code>Tokio</code>，所以这个时候，我们又使用到了绿色线程，但这个时候管理绿色线程的运行时，不是语言本身提供的，而是第三方库提供的。当你用不上异步代码时，你也就不会加载这个多余的运行时。</p><p>同样的这个<code>Future</code>模型也可以实现为<code>async</code>和<code>await</code>语法，这是非常棒的，我们期待稳定后的Rust1.39。</p><p>这个模型属于零成本抽象的范畴。原因是：它符合了零成本抽象的两条定义。</p><h2 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h2><p><a href="https://boats.gitlab.io/blog/" target="_blank" rel="noopener">Without Boats Blog</a><br><a href="https://rustlang-cn.org/office/rust/book/concurrency/ch16-01-threads.html" target="_blank" rel="noopener">The Book 使用线程同时运行代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在看先前的拉丁美洲的Rustconf，偶然看到了&lt;em&gt;Without Boats&lt;/em&gt;大佬的关于零成本异步IO的介绍。&lt;/p&gt;
&lt;p&gt;在其中学习到一些异步编程模型，在此做一个总结。 &lt;/p&gt;
&lt;p&gt;视频链接：&lt;a href=&quot;https://youtu.be/skos4B5x7qE?list=PL85XCvVPmGQjuWUNeFCgl8X2EOC_aAq5N&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Without Boats: Zero-Cost Async IO&lt;/a&gt;&lt;/p&gt;
&lt;iframe width=&quot;889&quot; height=&quot;500&quot; src=&quot;https://www.youtube.com/embed/skos4B5x7qE?list=PL85XCvVPmGQjuWUNeFCgl8X2EOC_aAq5N&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&quot; allowfullscreen&gt;&lt;/iframe&gt;
    
    </summary>
    
      <category term="Rust" scheme="http://www.kingr.top/categories/Rust/"/>
    
    
      <category term="Rust" scheme="http://www.kingr.top/tags/Rust/"/>
    
      <category term="异步" scheme="http://www.kingr.top/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>尝试rust ffi，rust调用clang</title>
    <link href="http://www.kingr.top/2019/09/02/rust-ffi-test/"/>
    <id>http://www.kingr.top/2019/09/02/rust-ffi-test/</id>
    <published>2019-09-02T02:53:54.000Z</published>
    <updated>2019-09-09T08:15:42.750Z</updated>
    
    <content type="html"><![CDATA[<p>最近试图想用rust做一个小工具，但是rust上目前还没有对应的库，而C语言中有对应的库。想尝试使用这个库，我需要先了解一下rust ffi（Foreign Function Interface）。</p><p>要想将rust的ffi应用到一整个库上，首先我们先从一个文件做起。</p><p>这篇文章就是对rust ffi 一次小小尝试的记录。</p><a id="more"></a><h2 id="编写一个c，并编译为库"><a href="#编写一个c，并编译为库" class="headerlink" title="编写一个c，并编译为库"></a>编写一个c，并编译为库</h2><p>我们在一个新建的rust项目的src目录下，新建一个<code>add.c</code>。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//src/add.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在命令行中执行：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">clang -c add.c -o libadd.a</span><br></pre></td></tr></table></figure></p><p>将我们新建的c文件编译为一个可以被引入的库文件。现在我们<code>src</code>目录下结构就是这样的:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- src</span><br><span class="line">    - add.c</span><br><span class="line">    - libadd.a</span><br><span class="line">    - main.rs</span><br></pre></td></tr></table></figure><h2 id="编写main-rs"><a href="#编写main-rs" class="headerlink" title="编写main.rs"></a>编写main.rs</h2><p>我们如果想要在<code>main.rs</code>中调用我们在<code>add.c</code>中定义的add函数，我们需要将它引入，并且在<code>unsafe</code>代码块中使用。<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::os::raw::c_int;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(a, c_int, b: c_int) -&gt; c_int;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">unsafe</span> &#123; add(<span class="number">1</span>, <span class="number">2</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"1 + 2 = &#123;&#125;"</span>，result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="编译main-rs"><a href="#编译main-rs" class="headerlink" title="编译main.rs"></a>编译main.rs</h2><p>也许这个时候，你会试图想要用<code>cargo run</code>来运行你的代码。但是这是行不通的，会报<code>undefined reference</code>错误。因为cargo并不知道我们，我们需要链接的库文件在哪里。</p><p>试一试这个：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rustc main.rs -L. -ladd &amp;&amp; ./main</span><br></pre></td></tr></table></figure></p><p>你可以看到输出了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 + 2 = 3</span><br></pre></td></tr></table></figure></p><p>我们可以使用<code>rustc --help</code>查看<code>-L</code>和<code>-l</code> flag分别代表着什么。</p><ul><li><code>-L</code> 添加lib搜寻的目录</li><li><code>-l</code> 添加lib</li></ul><h2 id="使用cargo-编译"><a href="#使用cargo-编译" class="headerlink" title="使用cargo 编译"></a>使用cargo 编译</h2><p>想要用<code>cargo</code>编译，需要在项目根目录下新建一个<code>build.rs</code></p><p>cargo 会读取<code>build.rs</code>的输出，来设置我们编译时的配置</p><p>在这里我们最小化的一个main.rs就是长这样的<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//build.rs</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"cargo:rustc-link-search=./src"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"cargo:rustc-link-lib=add"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体更多的可以被<code>cargo</code>识别的配置可以在这里找到：<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html" target="_blank" rel="noopener">build script</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://s3.amazonaws.com/temp.michaelfbryan.com/linking/index.html" target="_blank" rel="noopener">Linking and Building</a></li><li><a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html" target="_blank" rel="noopener">Build Script</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近试图想用rust做一个小工具，但是rust上目前还没有对应的库，而C语言中有对应的库。想尝试使用这个库，我需要先了解一下rust ffi（Foreign Function Interface）。&lt;/p&gt;
&lt;p&gt;要想将rust的ffi应用到一整个库上，首先我们先从一个文件做起。&lt;/p&gt;
&lt;p&gt;这篇文章就是对rust ffi 一次小小尝试的记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Rust" scheme="http://www.kingr.top/categories/Rust/"/>
    
    
      <category term="rust" scheme="http://www.kingr.top/tags/rust/"/>
    
      <category term="ffi" scheme="http://www.kingr.top/tags/ffi/"/>
    
  </entry>
  
  <entry>
    <title>你应该试试这个科学上网工具clash-node</title>
    <link href="http://www.kingr.top/2019/05/13/clash-node-instruction/"/>
    <id>http://www.kingr.top/2019/05/13/clash-node-instruction/</id>
    <published>2019-05-13T07:06:40.000Z</published>
    <updated>2019-09-02T04:38:15.856Z</updated>
    
    <content type="html"><![CDATA[<p>我觉得使用linux的你应该尝试一下使用这个工具科学上网，自从ssr发展了科学上网节点的订阅形式之后，各大的机场都支持了订阅，由于日渐增高的墙，许许多多的科学上网的工具也都层出不穷，但不是所有工具都支持订阅链接导入的方式获取节点，许多的工具还都只能够手动更改配置运行，尤其是对linux的用户来说。<a href="https://github.com/Dreamacro/clash" target="_blank" rel="noopener">clash</a>是其中一款，非常棒的工具，我正在使用它，但没有linux下的支持订阅的实现。<br>所以我写了一个工具<a href="https://github.com/kingrongH/clash-node" target="_blank" rel="noopener">clash-node</a>，支持订阅链接。</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这个工具是使用Node.js + typescript 完成了一个clash的包装, 实现订阅链接的一个功能，核心的代理功能还是由<a href="https://github.com/Dreamacro/clash" target="_blank" rel="noopener">clash</a> 来实现的。当然它不仅仅是只有订阅链接的功能，那样的话我们使用的人会无从下手的，我正是从我日常使用的一个角度来考虑如何设计这个功能的。他还可以直接开启和关闭clash的功能，以及正在测试的切换链接的功能。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ol><li>Node.js</li></ol><p>最好是10及以上的版本，推荐使用<code>nvm</code>来管理和安装nodejs</p><p><a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">nvm</a></p><ol start="2"><li>npm or cnpm or yarn</li></ol><p>你可以使用你想要用的那一个node.js包管理器。<br>中国用户推荐使用<code>cnpm</code></p><ol start="3"><li>typescript</li></ol><p>你需要有<code>typescript</code>的支持。<br>通过</p><pre><code>npm install -g typescript</code></pre><p>来完成一个全局的安装，如果你只想要本地安装的话：</p><pre><code>npm install typescript</code></pre><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>现在来说只能通过<code>github</code>进行安装。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/kingrongH/clash-node</span><br><span class="line">cd clash-node</span><br><span class="line">npm install</span><br><span class="line">npm build</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>工具本身使用是符合日常用户的使用习惯的。只需要通过终端运行一些命令即可。</p><h3 id="订阅链接"><a href="#订阅链接" class="headerlink" title="订阅链接"></a>订阅链接</h3><h4 id="添加订阅"><a href="#添加订阅" class="headerlink" title="添加订阅"></a>添加订阅</h4><p>订阅链接我们需要这么做，在项目文件的根目录下：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd bin</span><br><span class="line">node clash-node.js addSub</span><br></pre></td></tr></table></figure></p><p>然后接下来根据提示完成订阅链接的添加即可。它看起来像这样：</p><p><img src="https://camo.githubusercontent.com/ee554091b16ceb6073636ffeb8949ce5274a08b7/68747470733a2f2f692e6c6f6c692e6e65742f323031392f30342f32392f356363373030613234386633362e706e67" alt="订阅链接"></p><p>这个时候链接的名称和链接地址以及节点信息，已经分别放到对应配置文件中了。</p><h4 id="更新订阅"><a href="#更新订阅" class="headerlink" title="更新订阅"></a>更新订阅</h4><p>更新已经在配置文件中的订阅同样简单：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node clash-node.js updateSub</span><br></pre></td></tr></table></figure><h3 id="运行clash"><a href="#运行clash" class="headerlink" title="运行clash"></a>运行clash</h3><p>在我们更新订阅节点信息之后，我们就可以直接运行clash作为代理了。运行以下命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node clash-node.js start</span><br></pre></td></tr></table></figure><p>这个时候应该就可以看到任务管理中有正在运行的clash了，打开<a href="www.google.com">google</a>试试。</p><p>关闭正在运行的clash进程:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node clash-node.js stop</span><br></pre></td></tr></table></figure></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置和<a href="https://github.com/Dreamacro/clash" target="_blank" rel="noopener">clash</a>的配置一样，你可以在<code>./config/config.yml</code>中配置除了<code>Proxy</code>、<code>Proxy Group</code>和<code>Rule</code>以外的配置，clash-node在运行的时候会读取这里的配置。</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p><a href="https://github.com/Dreamacro/clash" target="_blank" rel="noopener">Dreamacro/clash</a></p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>如果你有任何关于这个工具的想法或者建议，可以联系我，或者提request or issue</p><p><a href="https://github.com/kingrongH/clash-node" target="_blank" rel="noopener">github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我觉得使用linux的你应该尝试一下使用这个工具科学上网，自从ssr发展了科学上网节点的订阅形式之后，各大的机场都支持了订阅，由于日渐增高的墙，许许多多的科学上网的工具也都层出不穷，但不是所有工具都支持订阅链接导入的方式获取节点，许多的工具还都只能够手动更改配置运行，尤其是对linux的用户来说。&lt;a href=&quot;https://github.com/Dreamacro/clash&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;clash&lt;/a&gt;是其中一款，非常棒的工具，我正在使用它，但没有linux下的支持订阅的实现。&lt;br&gt;所以我写了一个工具&lt;a href=&quot;https://github.com/kingrongH/clash-node&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;clash-node&lt;/a&gt;，支持订阅链接。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.kingr.top/categories/JavaScript/"/>
    
    
      <category term="clash" scheme="http://www.kingr.top/tags/clash/"/>
    
      <category term="ssr" scheme="http://www.kingr.top/tags/ssr/"/>
    
      <category term="vmess" scheme="http://www.kingr.top/tags/vmess/"/>
    
      <category term="nodejs" scheme="http://www.kingr.top/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>网址中的中文编码和解码方法</title>
    <link href="http://www.kingr.top/2019/04/30/urlDecodeChinese/"/>
    <id>http://www.kingr.top/2019/04/30/urlDecodeChinese/</id>
    <published>2019-04-30T05:15:57.000Z</published>
    <updated>2019-04-30T14:33:29.558Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在chrome的地址栏上输入中文的进行搜索之后，我们敲入的关键词在这个时候被编码成了我们看不懂的一串由<code>%</code>和十六进制数组成的东西。</p><p>比如:</p><pre><code>中文搜索</code></pre><p>被编码成了</p><pre><code>%E4%B8%AD%E6%96%87%E6%90%9C%E7%B4%A2</code></pre><p>所以如何它是如何编码和解码中文的呢？<br><a id="more"></a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>根据阮一峰老师的博客<a href="http://www.ruanyifeng.com/blog/2010/02/url_encoding.html" target="_blank" rel="noopener">关于URL编码</a>，我们得知了以下结论:</p><ul><li>网址路径采用的是UTF-8编码</li><li>查询字符串的编码用的是操作系统默认的编码</li><li><code>GET/POST</code>用的是网页的编码（GB2312或者UTF-8）<ul><li><code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=xxxx&quot;&gt;</code>xxxx是啥就进行什么编码</li></ul></li><li>在AJAX请求中，IE采用的是系统编码(GB2312)，Firefox 总是采用UTF-8</li></ul><p>所有以上的这些结论都是在将中文字符转化为各自的编码集之后在每个字节前加上<code>%</code>得到的结果。</p><p>比如：<code>中文</code>使用utf-8编码得到<code>e4b8ade69687</code>，其中<code>中</code>对应<code>e4b8ad</code>，<code>文</code>对应<code>e69687</code>。在一个字节前加上<code>%</code>就得到了<code>%e4%b8%ad%e6%96%87</code>。</p><p>至于utf-8具体是如何编码的，请参见：<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">阮一峰-字符编码笔记：ASCII，Unicode 和 UTF-8</a>。</p><h2 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法"></a>解码方法</h2><p>了解了网址中中问编码的原理，我决定尝试一下使用nodejs实现一个网址解码的函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">urlDecode</span>(<span class="params">str,charset</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> bytes = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;str.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(str[i]===<span class="string">"%"</span>)&#123;</span><br><span class="line">bytes.push(<span class="built_in">parseInt</span>(str.substring(i+<span class="number">1</span>,i+<span class="number">3</span>),<span class="number">16</span>));</span><br><span class="line">i = i+<span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">bytes.push(str.charCodeAt(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> buf = Buffer.from(bytes);</span><br><span class="line"><span class="keyword">return</span> buf.toString(charset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想法自然就是将所有的字节都分离出来，添加为一个数组，将这个数组转为nodejs的二进制数据流Buffer，然后再转为utf-8。<br>这个方式只能解码utf-8的字符了，如果是使用GB2312 编码参见：<a href="https://www.npmjs.com/package/iconv-lite" target="_blank" rel="noopener">iconv-lite</a>。</p><p>以下是该库所支持的编码方式，不仅可用于解码还可以用于编码。</p><blockquote><p>All node.js native encodings: utf8, ucs2 / utf16-le, ascii, binary, base64, hex.<br>Additional unicode encodings: utf16, utf16-be, utf-7, utf-7-imap.<br>All widespread singlebyte encodings: Windows 125x family, ISO-8859 family, IBM/DOS codepages, Macintosh family, KOI8 family, all others supported by iconv library. Aliases like ‘latin1’, ‘us-ascii’ also supporte<br>All widespread multibyte encodings: CP932, CP936, CP949, CP950, GB2312, GBK, GB18030, Big5, Shift_JIS, EUC-JP.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们在chrome的地址栏上输入中文的进行搜索之后，我们敲入的关键词在这个时候被编码成了我们看不懂的一串由&lt;code&gt;%&lt;/code&gt;和十六进制数组成的东西。&lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;中文搜索
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;被编码成了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%E4%B8%AD%E6%96%87%E6%90%9C%E7%B4%A2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以如何它是如何编码和解码中文的呢？&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.kingr.top/categories/JavaScript/"/>
    
    
      <category term="nodejs" scheme="http://www.kingr.top/tags/nodejs/"/>
    
      <category term="url" scheme="http://www.kingr.top/tags/url/"/>
    
      <category term="decode" scheme="http://www.kingr.top/tags/decode/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 解析vmess链接，供clash-linux使用</title>
    <link href="http://www.kingr.top/2019/04/12/js-decode-for-clash/"/>
    <id>http://www.kingr.top/2019/04/12/js-decode-for-clash/</id>
    <published>2019-04-12T06:35:01.000Z</published>
    <updated>2019-04-12T09:36:12.765Z</updated>
    
    <content type="html"><![CDATA[<p>今天我决定将我使用JavaScript开发了一个vmess解析工具的记录po给大家看。这个工具主要是为<a href="https://github.com/Dreamacro/clash" target="_blank" rel="noopener">clash</a> linux版本设计的，包含获取vmess订阅链接内容，和解析单个链接等功能。</p><a id="more"></a><h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>之前，我曾经使用过Python来解析ssr和ss链接，当时为自己做了这样一个小工具而兴奋不已，但是这样一个过于简单的没有经过系统设计的工具，难以逃脱短命、不被更新和被主人抛弃的命运。当时因为在Linux系统上没有ssr订阅链接的工具而倍感苦恼，下决心自己写下来一个可以订阅ssr的工具，甚至还打算了为我自己的工具做一个界面。然后，在我的脑海中夭折，甚至已经出来的功能都是现学现做的，漏洞甚多，弃。</p><p>当时这样的想法算是一时冲动，但是同现在的想法却有几分相似。我想做这样一件事情是因为：</p><ul><li>clash-linux作为一个工具来说非常的好用</li><li>clash使用yaml配置文件作为它节点的接口，非常适合进一步开发</li><li>clash没有支持vmess链接导入的功能</li><li>我喜欢折腾</li></ul><p>大抵是因为这样，我为自己做了这样一个工具。</p><h2 id="一一对应"><a href="#一一对应" class="headerlink" title="一一对应"></a>一一对应</h2><p>在手动配置clash的config.yml的时候，我便有一些困惑，和其他vmess工具使用配置属性名称都不一样。</p><p>一个clash的vmess配置大概长这样：</p><pre><code>{ name: &quot;vmess&quot;, type: vmess, server: server, port: 443, uuid: uuid, alterId: 32, cipher: auto, tls: true }</code></pre><p>而v2ryN的配置长这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;v&quot;: &quot;2&quot;,</span><br><span class="line">&quot;ps&quot;: &quot;备注别名&quot;,</span><br><span class="line">&quot;add&quot;: &quot;111.111.111.111&quot;,</span><br><span class="line">&quot;port&quot;: &quot;32000&quot;,</span><br><span class="line">&quot;id&quot;: &quot;1386f85e-657b-4d6e-9d56-78badb75e1fd&quot;,</span><br><span class="line">&quot;aid&quot;: &quot;100&quot;,</span><br><span class="line">&quot;net&quot;: &quot;tcp&quot;,</span><br><span class="line">&quot;type&quot;: &quot;none&quot;,</span><br><span class="line">&quot;host&quot;: &quot;www.bbb.com&quot;,</span><br><span class="line">&quot;path&quot;: &quot;/&quot;,</span><br><span class="line">&quot;tls&quot;: &quot;tls&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两个配置文件的范例分别可以在<a href="https://github.com/Dreamacro/clash" target="_blank" rel="noopener">clash</a> 和<a href="https://github.com/2dust/v2rayN/wiki/%E5%88%86%E4%BA%AB%E9%93%BE%E6%8E%A5%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E(ver-2" target="_blank" rel="noopener">v2rayN wiki</a>)。</p><p>我并没有一下子就建立起来两者的一一对应关系，而是花了一些时间。我在接下来的格式解析的过程中肯定需要使用到这样一个一一对应的关系的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> table = &#123;</span><br><span class="line">ps:<span class="string">"name"</span>,</span><br><span class="line">add:<span class="string">"server"</span>,</span><br><span class="line">port:<span class="string">"port"</span>,</span><br><span class="line">id:<span class="string">"uuid"</span>,</span><br><span class="line">aid:<span class="string">"alterId"</span>,</span><br><span class="line">security:<span class="string">"cipher"</span>,</span><br><span class="line">tls:<span class="string">"tls"</span>, <span class="comment">// vmess中value为"tls"或者""，而clash中为true/false</span></span><br><span class="line">net:<span class="string">"network"</span> <span class="comment">//vmess 支持tcp，clash不支持</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中一些需要注意的点写在了注释中，另一些vmess有的而clash没有的要么是不支持要么是没紧要的。</p><h2 id="JavaScript解码base64"><a href="#JavaScript解码base64" class="headerlink" title="JavaScript解码base64"></a>JavaScript解码base64</h2><p>vmess链接的格式为<code>vmess://[base64编码的节点信息]</code>所以我自然需要知道在JavaScript如何解码base64的字符串。我的代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* decode base64</span></span><br><span class="line"><span class="comment"> * note: because vmess support return for a encoded string, add a trim char check</span></span><br><span class="line"><span class="comment"> * @param s string </span></span><br><span class="line"><span class="comment"> * @return string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decode</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line"><span class="comment">//delete the \n\r </span></span><br><span class="line">s.replace(<span class="regexp">/\s+/g</span>,<span class="string">""</span>);</span><br><span class="line"><span class="keyword">if</span>(s.length%<span class="number">4</span> !== <span class="number">0</span>)&#123;</span><br><span class="line">s = s + s.length%<span class="number">4</span>*<span class="string">"="</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> buf = Buffer.from(s, <span class="string">'base64'</span>);</span><br><span class="line"><span class="keyword">return</span> buf.toString(<span class="string">'utf8'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* decode vmess, ss or ssr link</span></span><br><span class="line"><span class="comment"> * @param s string</span></span><br><span class="line"><span class="comment"> * @return string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">linkDecode</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line"><span class="comment">//judge if supported link</span></span><br><span class="line"><span class="keyword">if</span>(s.startsWith(<span class="string">"vmess://"</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> decode(s.substring(<span class="number">8</span>));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.startsWith(<span class="string">"ssr://"</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> decode(s.substring(<span class="number">6</span>));</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.startsWith(<span class="string">"ss://"</span>))&#123;</span><br><span class="line"><span class="keyword">return</span> decode(s.substring(<span class="number">5</span>));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.warn(<span class="string">"a illegal link: "</span>+ <span class="string">`<span class="subst">$&#123;s&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里包含两个部分，一个单纯的解码字符串，一个是针对链接来解码，为了以后，我多做了一些工作，不过可能是白做，哈哈哈。</p><p>之所以去除字符串中的空白字符，是因为在测试过程中发现v2rayN支持的先加密后换行的格式。</p><h2 id="解析为json对象"><a href="#解析为json对象" class="headerlink" title="解析为json对象"></a>解析为json对象</h2><p>获取到字符串格式的节点信息之后，需要将这些信息提取出来到一个JavaScript对象中，以便做进一步处理</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* parse string to obj</span></span><br><span class="line"><span class="comment"> * @param s string</span></span><br><span class="line"><span class="comment"> * @return object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> s !== <span class="string">"string"</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.warn(<span class="string">`parsing a not-string obj: <span class="subst">$&#123;s&#125;</span> aborted!`</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">var</span> ob = <span class="built_in">JSON</span>.parse(s);</span><br><span class="line"><span class="keyword">return</span> ob;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回包含节点信息的对象ob</p><h2 id="转换为clash格式"><a href="#转换为clash格式" class="headerlink" title="转换为clash格式"></a>转换为clash格式</h2><p>参照我们之前制作的那个table对象，我们再将获得的含有节点信息的对象，一一转换为clash支持的形式，并返回新的对象。我的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* convert the obj from vmess link to the obj that clash accept</span></span><br><span class="line"><span class="comment"> * @param ob object</span></span><br><span class="line"><span class="comment"> * @return object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clashFormat</span>(<span class="params">ob</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(ob)!==<span class="string">"object"</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.warn(<span class="string">"clash Format:can only format object"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//a table for refer</span></span><br><span class="line"><span class="keyword">var</span> table = &#123;</span><br><span class="line">ps:<span class="string">"name"</span>,</span><br><span class="line">add:<span class="string">"server"</span>,</span><br><span class="line">port:<span class="string">"port"</span>,</span><br><span class="line">id:<span class="string">"uuid"</span>,</span><br><span class="line">aid:<span class="string">"alterId"</span>,</span><br><span class="line">security:<span class="string">"cipher"</span>,</span><br><span class="line">tls:<span class="string">"tls"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> defaultV = &#123;</span><br><span class="line">name:<span class="string">"local"</span>,</span><br><span class="line">type:<span class="string">"vmess"</span>,</span><br><span class="line">server:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">port:<span class="number">1080</span>,</span><br><span class="line">uuid:<span class="string">""</span>,</span><br><span class="line">alterId:<span class="number">0</span>,</span><br><span class="line">cipher:<span class="string">"auto"</span>,</span><br><span class="line">tls:<span class="literal">false</span>,</span><br><span class="line"><span class="string">"skip-cert-verify"</span>:<span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> ob)&#123;</span><br><span class="line"><span class="keyword">if</span>(key === <span class="string">"tls"</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(ob[key]===<span class="string">"tls"</span>)&#123;</span><br><span class="line">defaultV[table[key]] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(table[key])&#123;</span><br><span class="line">defaultV[table[key]] = ob[key];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> defaultV;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我建立一个默认值的对象，便于修改。对我们获取到的对象中的属性遍历，如果是table中存在的，将defaultV中对应的值赋给ob中对应的值，最后返回defaultV。其中我们需要对一些特殊的属性做一些特殊处理，比如<code>tls</code>它在两种格式中值的类型是不一样的，需要做转换。</p><p>目前我还没有加入<code>network</code>支持，因为我所知的大部分机场都使用的<code>tcp</code>而clash还没有支持这个。</p><h2 id="序列化为字符串"><a href="#序列化为字符串" class="headerlink" title="序列化为字符串"></a>序列化为字符串</h2><p>对于获得clash格式的对象，我们需要将它序列化为字符串，便于输出，无论是写入文件还是输出到终端。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* parse object to yarml format, return a string</span></span><br><span class="line"><span class="comment"> * note: this only can parse obj returned from clashFormat()</span></span><br><span class="line"><span class="comment"> * @param ob object</span></span><br><span class="line"><span class="comment"> * @return string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objParseToYaml</span>(<span class="params">ob</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span>(ob)!==<span class="string">"object"</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">"Only can parse object"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify(ob);</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，一开始我以为，clash所支持的yaml的配置是需要去除引号，但是保留name值的引号的，因为官方的配置是只保留了name值的引号，所以我费了一番功夫，想要保留这个引号同时去除其他的引号。后来经过我的一些测试发现不需要这么做，一个引号也不用去除。为了保证clash不会报错，我确实一个也没有去除。只是美观不足而已，所以得到的字符串大概长这样</p><pre><code>{&quot;name&quot;:&quot;xxxx&quot;,&quot;type&quot;:&quot;vmess&quot;,&quot;server&quot;:&quot;xxxx.xxx.xx&quot;,&quot;port&quot;:&quot;443&quot;,&quot;uuid&quot;:&quot;27848739-7e62-4138-9fd3-098a63964b6b&quot;,&quot;alterId&quot;:&quot;0&quot;,&quot;cipher&quot;:&quot;auto&quot;,&quot;tls&quot;:false}</code></pre><p>如果将这个放到配置文件中却是不怎么好看。</p><p>到这里我们的工作可以说完成了核心部分了。但是我们还有更进一步的事情需要做，比如输出，比如获取订阅链接。不过都是一些外层的设计，但是对我来说，却是更难的部分。</p><h2 id="获取订阅链接内容"><a href="#获取订阅链接内容" class="headerlink" title="获取订阅链接内容"></a>获取订阅链接内容</h2><p>获取订阅链接的内容，在JavaScript中我们需要调用到<code>http</code>和<code>https</code>，因为我们无法保证机场使用的都是一样的协议，所以我们两个都引入。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">"https"</span>);</span><br></pre></td></tr></table></figure><p>nodejs中几乎所有的http和https操作都是异步的，所以我们需要考虑到返回值的问题。相对于其他的编程语言来说，获取响应这个部分确实是更加的麻烦了。但是在这样的繁复中至少我们还有语法糖<code>async/await</code>，整个编码过程都甜蜜了一些。</p><p>一开始我以为，获取订阅链接响应的代码只要这么写就够了：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* handle subscribe link, get the response</span></span><br><span class="line"><span class="comment"> * @param url</span></span><br><span class="line"><span class="comment"> * @return Promise resove(string)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRes</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> url !== <span class="string">"string"</span> || !(url.startsWith(<span class="string">"http://"</span>) || url.startsWith(<span class="string">"https://"</span>)))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Only can handle link format!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(url.startsWith(<span class="string">"http://"</span>))&#123;</span><br><span class="line"><span class="keyword">var</span> req = http.get(url,(res)=&gt;&#123;</span><br><span class="line"><span class="keyword">if</span>(res.statusCode !== <span class="number">200</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Request failed please check your Internet connection!\n"</span> + <span class="string">`statusCode: <span class="subst">$&#123;res.statusCode&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">res.on(<span class="string">"data"</span>,(chunk)=&gt;&#123;</span><br><span class="line">resolve(chunk)</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(url.startsWith(<span class="string">"https://"</span>))&#123;</span><br><span class="line"><span class="keyword">var</span> req = https.get(url,(res)=&gt;&#123;</span><br><span class="line"><span class="keyword">if</span>(res.statusCode !== <span class="number">200</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Request failed please check your Internet connection!\n"</span> + <span class="string">`statusCode: <span class="subst">$&#123;res.statusCode&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">res.setEncoding(<span class="string">"utf8"</span>);</span><br><span class="line">res.on(<span class="string">"data"</span>,(chunk)=&gt;&#123;</span><br><span class="line">resolve(chunk);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来似乎没什么问题，我返回了一个Promise对象，resolve了我请求到的数据，并且考虑到了种种Error的情况，在接下来的操作中我只需要<code>await</code>这个函数完成，返回我们的响应数据，多么美好。</p><p>然而我还是太天真了，有一些机场他们更愿意使用<code>stream</code>类型来传回数据，就连我们获得的响应也都是突突突一阵一阵的（忽然想起来普朗克），这种情况下，我可能只是获得了第一阵的数据，就开始急急忙忙地进行下一步操作了。所以我们应该等整个请求完成了再<code>resolve</code>获得的整个数据。代码看起来如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* handle subscribe link, get the response</span></span><br><span class="line"><span class="comment"> * @param url</span></span><br><span class="line"><span class="comment"> * @return Promise resove(string)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRes</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> url !== <span class="string">"string"</span> || !(url.startsWith(<span class="string">"http://"</span>) || url.startsWith(<span class="string">"https://"</span>)))&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Only can handle link format!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">var</span> strings = [];</span><br><span class="line"><span class="keyword">if</span>(url.startsWith(<span class="string">"http://"</span>))&#123;</span><br><span class="line"><span class="keyword">var</span> req = http.get(url,(res)=&gt;&#123;</span><br><span class="line"><span class="keyword">if</span>(res.statusCode !== <span class="number">200</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Request failed please check your Internet connection!\n"</span> + <span class="string">`statusCode: <span class="subst">$&#123;res.statusCode&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">res.on(<span class="string">"data"</span>,(chunk)=&gt;&#123;</span><br><span class="line">strings.push(chunk);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(url.startsWith(<span class="string">"https://"</span>))&#123;</span><br><span class="line"><span class="keyword">var</span> req = https.get(url,(res)=&gt;&#123;</span><br><span class="line"><span class="keyword">if</span>(res.statusCode !== <span class="number">200</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Request failed please check your Internet connection!\n"</span> + <span class="string">`statusCode: <span class="subst">$&#123;res.statusCode&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">res.setEncoding(<span class="string">"utf8"</span>);</span><br><span class="line">res.on(<span class="string">"data"</span>,(chunk)=&gt;&#123;</span><br><span class="line"><span class="keyword">if</span>(chunk)&#123;</span><br><span class="line">strings.push(chunk);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// once the request done, join the chunks together, and resolve it</span></span><br><span class="line">req.on(<span class="string">'close'</span>,()=&gt;&#123;</span><br><span class="line">resolve(strings.join(<span class="string">""</span>));</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在返回的Promise对象中定义了一个字符串数组，并且将每一次获取到的数据都<code>push</code>进去，在请求结束之后，将数组中所有的数据<code>join</code>到一起，然后<code>resolve</code>它，美滋滋。</p><h2 id="集中处理订阅数据"><a href="#集中处理订阅数据" class="headerlink" title="集中处理订阅数据"></a>集中处理订阅数据</h2><p>我们获取到了一堆base64编码后的数据它很长，我们要对这个长长的数据做进一步处理：解码、解析和输出。这个数据在base64编码之前是以换行符分开不同的<code>vmess</code>链接的，我们获取该数据后，解码，再以空白字符分割，对每一个链接再进行解码，解析，转换clash格式，序列化和输出。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// async function used to handle data get from getRes()</span></span><br><span class="line"><span class="comment">// split the data to the list and convert ervery one to the clash supported format</span></span><br><span class="line"><span class="comment">// and parse the link to the yarml string </span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">handleSubData</span>(<span class="params">subUrl</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">""</span>;</span><br><span class="line">data = <span class="keyword">await</span> getRes(subUrl);</span><br><span class="line"><span class="keyword">var</span> linkList = decode(data).split(<span class="regexp">/\s+/</span>);</span><br><span class="line"><span class="keyword">var</span> configs = [];</span><br><span class="line"><span class="keyword">var</span> configStrings = [];</span><br><span class="line"><span class="keyword">var</span> names = [];</span><br><span class="line"><span class="keyword">for</span>(link <span class="keyword">of</span> linkList)&#123;</span><br><span class="line"><span class="comment">//if link is not empty string</span></span><br><span class="line"><span class="keyword">if</span>(link)&#123;</span><br><span class="line"><span class="keyword">let</span>temp = linkDecode(link);</span><br><span class="line"><span class="keyword">let</span> tempObj = parse(temp);</span><br><span class="line"><span class="keyword">let</span> tempClashObj = clashFormat(tempObj);</span><br><span class="line">configs.push(tempClashObj);</span><br><span class="line">names.push(tempClashObj.name);</span><br><span class="line"><span class="keyword">let</span> tempClashStr = objParseToYaml(tempClashObj);</span><br><span class="line"><span class="comment">// log like this is to make it easier to copy and paste</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"- "</span> + tempClashStr);</span><br><span class="line">configStrings.push(tempClashStr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(names);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* cli support </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">shellStart</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> rl =readline.createInterface(&#123;</span><br><span class="line">input:process.stdin,</span><br><span class="line">output:process.stdout</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">   rl.question(<span class="string">"Input the vmess link: "</span>, (answer)=&gt;&#123;</span><br><span class="line">handleSubData(answer);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Please wait the result!"</span>);</span><br><span class="line">rl.close();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你需要执行<code>shellStart()</code>，然后填入你的订阅链接，就会出来结果。</p><p>我输出了所有可以直接复制进去<code>config.yml</code>的所有节点信息和由所有节点的name值组成的一个数组，方便操作。</p><p>事实上，我可以使用更加美好的输出方式，比如输出到文本文件中，直接生成<code>config.yml</code>或者干脆做一个GUI，但是我没有，我只使用了<code>console.log</code>，你需要自己复制进去。也许未来我可以把更好的方式添加进去。</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>这个小工具花了一天多的时间。在编码的过程中，我尽量先在笔记中写下自己的思路，然后才开始编码。这种方式对我来说实在是大有裨益，难怪过来人都喜欢这么说:</p><blockquote><p>一个好的程序员应该花80%的时间编写文档，然后花20%的时间来写代码和debug。</p></blockquote><p>我对于这样一句话，现在有了更加深刻的理解。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>这样短小的代码量，还是有好些地方做不好，比如，也许你发现了，我在处理错误上并没有做好，我希望能够在接下来的时间慢慢地改进。</p><p>接下来还有很多要做的：</p><h5 id="todo"><a href="#todo" class="headerlink" title="todo:"></a>todo:</h5><ul><li>更好的错误处理方式，比如说写一个logger</li><li>更好的输出方式，比如生成<code>config.yml</code></li><li>更好的交互方式，比如cli+参数运行clash</li><li>更多的支持，比如支持<code>ss</code></li><li>…</li></ul><p>如果你能有更好的方式或者建议欢迎你在评论区提出，或者直接联系我<a href="https://github.com/kingrongH" target="_blank" rel="noopener">github</a>。</p><hr><p>参考链接：</p><pre><code>1. [clash](https://github.com/Dreamacro/clash)2. [v2rayN wiki](https://github.com/2dust/v2rayN/wiki)</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我决定将我使用JavaScript开发了一个vmess解析工具的记录po给大家看。这个工具主要是为&lt;a href=&quot;https://github.com/Dreamacro/clash&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;clash&lt;/a&gt; linux版本设计的，包含获取vmess订阅链接内容，和解析单个链接等功能。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.kingr.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.kingr.top/tags/JavaScript/"/>
    
      <category term="vmess" scheme="http://www.kingr.top/tags/vmess/"/>
    
      <category term="Clash" scheme="http://www.kingr.top/tags/Clash/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 链表的实现</title>
    <link href="http://www.kingr.top/2019/04/04/JSLinkdedList/"/>
    <id>http://www.kingr.top/2019/04/04/JSLinkdedList/</id>
    <published>2019-04-04T02:57:20.000Z</published>
    <updated>2019-04-04T08:14:26.980Z</updated>
    
    <content type="html"><![CDATA[<p>链表作为数据结构中的基础数据结构由许多的节点（node）组成。节点有两个东西组成：</p><ul><li>数据</li><li>指向一下个节点的指针</li></ul><p>使用JavaScript实现一个链表的结构需要创建两个类：一个是节点；一个则是链表。<br>创建好两个类之后，我们需要为我们创建的这个链表结构定义许多方法。</p><h2 id="链表的方法"><a href="#链表的方法" class="headerlink" title="链表的方法"></a>链表的方法</h2><p>通常情况下我们创造一个链表是为了更加方便的操作数据所以链表需要包含一些基本操作方法。</p><p>链表需要包含的操作方法有：</p><ul><li>在之后插入：<code>append(node,value)</code></li><li>搜索：<code>find(value)</code></li><li>删除：<code>remove(value)</code></li></ul><p>以上的方法只是一个大致的表示，具体实现还是要看代码怎么写。</p><h2 id="链表类的实现"><a href="#链表类的实现" class="headerlink" title="链表类的实现"></a>链表类的实现</h2><p>我们需要创建两个类：</p><ul><li>Node(value)</li><li>Linkedlist(head)</li></ul><p>其中链表又头部定位，所以创建时需要传入头部参数</p><p>代码的实现也比较简单：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//define Linkedlist‘s node</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br><span class="line">Node.prototype = &#123;</span><br><span class="line"><span class="keyword">constructor</span>:node,</span><br><span class="line">next:null</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Define Linkedlist  and its methods</span><br><span class="line">function Linkedlist(head)&#123;</span><br><span class="line"><span class="keyword">this</span>.head = head;</span><br><span class="line">&#125;</span><br><span class="line">Linkedlist.prototype = &#123;</span><br><span class="line"><span class="keyword">constructor</span>:Linkedlist,</span><br><span class="line">append:append,</span><br><span class="line">find:find,</span><br><span class="line">remove:remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>我们使用构造函数来实现<code>Node</code>和<code>LinkedList</code>两个类，并且在其原型中预先定义好了方法。</p><h2 id="链表方法的实现"><a href="#链表方法的实现" class="headerlink" title="链表方法的实现"></a>链表方法的实现</h2><p>链表方法的实现却也是比较简单的。详情请看代码。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Next define the methods:</span></span><br><span class="line"><span class="comment"> * append(node,value)</span></span><br><span class="line"><span class="comment"> * find(value)</span></span><br><span class="line"><span class="comment"> * remove(value)</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">append</span>(<span class="params">node,value</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> NewNode = <span class="keyword">new</span> Node(value)</span><br><span class="line">NewNode.next = node.next;</span><br><span class="line">node.next = NewNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">node = <span class="keyword">this</span>.head;</span><br><span class="line"><span class="keyword">while</span>(value !== node.data &amp;&amp; node.data !== <span class="literal">null</span>)&#123;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">node = <span class="keyword">this</span>.head;</span><br><span class="line"><span class="keyword">if</span> (head.data === value) &#123;</span><br><span class="line"><span class="keyword">this</span>.head=node.next;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(node.next.data !== value &amp;&amp; node.next.data !== <span class="literal">null</span>)&#123;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node.data !== <span class="literal">null</span>)&#123;</span><br><span class="line">node.next = node.next.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们只是实现了链表结构的三个方法，如果需要实现更多的方法，请各位看官手动尝试。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用JavaScript来实习链表这样一个结构目的是为了更加深刻的理解数据结构中的链表的概念。关于链表的更多的知识可以参考：<a href="https://en.wikipedia.org/wiki/Linked_list" target="_blank" rel="noopener">链表wiki</a></p><p>如有错误，欢迎各位指正！也欢迎各位在评论区提出意见。</p><hr><p>参考链接：</p><p><a href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/data-structures/linked-list" target="_blank" rel="noopener">github Javascript-algorithms</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;链表作为数据结构中的基础数据结构由许多的节点（node）组成。节点有两个东西组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据&lt;/li&gt;
&lt;li&gt;指向一下个节点的指针&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用JavaScript实现一个链表的结构需要创建两个类：一个是节点；一个则是链表。&lt;br
      
    
    </summary>
    
      <category term="Algorithm" scheme="http://www.kingr.top/categories/Algorithm/"/>
    
    
      <category term="链表" scheme="http://www.kingr.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="JavaScript" scheme="http://www.kingr.top/tags/JavaScript/"/>
    
      <category term="algorithm" scheme="http://www.kingr.top/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>wps在暗色主题下显示灰色字解决</title>
    <link href="http://www.kingr.top/2019/04/04/wps-darkTheme-greyFont/"/>
    <id>http://www.kingr.top/2019/04/04/wps-darkTheme-greyFont/</id>
    <published>2019-04-04T02:01:36.000Z</published>
    <updated>2019-04-04T02:09:19.040Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇解决问题的记录。<br>wps在使用暗色主题的gonme下一直有一个问题：它的字体颜色总是灰色的。这对我的使用造成了很大的困扰，我每次使用wps编辑文档，都需要先转到亮色的主题下。</p><p>现在终于有了解决的办法。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>更新最新版本的wps2019版本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一篇解决问题的记录。&lt;br&gt;wps在使用暗色主题的gonme下一直有一个问题：它的字体颜色总是灰色的。这对我的使用造成了很大的困扰，我每次使用wps编辑文档，都需要先转到亮色的主题下。&lt;/p&gt;
&lt;p&gt;现在终于有了解决的办法。&lt;/p&gt;
&lt;h2 id=&quot;解决办法&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="解决问题" scheme="http://www.kingr.top/categories/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="linux" scheme="http://www.kingr.top/tags/linux/"/>
    
      <category term="wps" scheme="http://www.kingr.top/tags/wps/"/>
    
      <category term="dark theme" scheme="http://www.kingr.top/tags/dark-theme/"/>
    
  </entry>
  
  <entry>
    <title>coc-java：java exit with code 13</title>
    <link href="http://www.kingr.top/2019/04/03/coc-java-exit-with13/"/>
    <id>http://www.kingr.top/2019/04/03/coc-java-exit-with13/</id>
    <published>2019-04-03T11:56:55.000Z</published>
    <updated>2019-04-04T02:10:20.470Z</updated>
    
    <content type="html"><![CDATA[<p>这只是一篇简单的记录</p><p>今天在安装coc-java这个插件之后，遇到一个问题：<code>...java exit with code 13</code></p><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>因为<code>coc-java</code>在你打开一个java文件之后发现没有<code>jdt</code>会自动下载<a href="https://github.com/eclipse/eclipse.jdt.ls" target="_blank" rel="noopener">jdt.ls</a>，但是可能处于种种原因你在下载途中退出了，导致下载的的不完整，所以你以打开java文件就报错误。</p><p>这一点我觉得coc应当多做一些提示，避免我们下载中途退出，或者在网站上提供一下用户自己下载的方式。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>你只需要删了<code>~/.config/coc/extensions/coc-java-data/</code>下的所有文件，然后打开一个java文件，它提示下载，静静等待它下载完就好了。</p><p>或者在官网<a href="https://download.eclipse.org/jdtls/snapshots/?d" target="_blank" rel="noopener">eclipse jdt download</a>那一串文件中选择最新的那个下载然后解压内容到<code>~/.config/coc/extensions/coc-java-data/server/</code>中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这只是一篇简单的记录&lt;/p&gt;
&lt;p&gt;今天在安装coc-java这个插件之后，遇到一个问题：&lt;code&gt;...java exit with code 13&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;原因分析&quot;&gt;&lt;a href=&quot;#原因分析&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="解决问题" scheme="http://www.kingr.top/categories/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="vim" scheme="http://www.kingr.top/tags/vim/"/>
    
      <category term="coc" scheme="http://www.kingr.top/tags/coc/"/>
    
      <category term="java" scheme="http://www.kingr.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>若干数最小公倍数求法[JavaScript实现]</title>
    <link href="http://www.kingr.top/2019/03/04/smallestCommons/"/>
    <id>http://www.kingr.top/2019/03/04/smallestCommons/</id>
    <published>2019-03-04T11:30:12.000Z</published>
    <updated>2019-03-05T02:32:35.186Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>假设有这么一道题目：</p><blockquote><p>求给定任意个整数的最小公倍数。</p></blockquote><p><strong>你会怎么做？</strong></p><p>我们设想给定一个参数为数组，数组中包含我们要求最小公倍数的最小整数，返回一个值为这若干数的最小公倍数的整数。</p><p><strong>我建议你先自己想一想</strong></p><p>是的，我在学习的过程中遇到了这样一个题目，并且苦思冥想了好些时间，终于让我给找到一个方法。接下来我将来阐述我解答这道题的思路。总共包含一下几个部分：</p><ul><li>最大公约数算法</li><li>若干数最小公倍数思路</li><li>具体JavaScript实现</li></ul><h2 id="最大公约数算法"><a href="#最大公约数算法" class="headerlink" title="最大公约数算法"></a>最大公约数算法</h2><p>学计算机的同学都知道有这样一个算法，名字叫做欧几里得算法，来自古希腊的数学家欧几里得，又叫做辗转相除法。对于学习过的同学，我想你已经可以不必要看这一小节了。关于欧几里得算法它是这样描述的：</p><blockquote><p>两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。最大公约数（Greatest Common Divisor）缩写为GCD。</p></blockquote><p>这样简洁的描述，让我们来JavaScript实现它吧。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gcd</span>(<span class="params">p,q</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(q===<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> gcd(q,p%q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么会用到最大公约数的算法呢，接下来的思路里解释。</p><h2 id="若干数最小公倍数思路"><a href="#若干数最小公倍数思路" class="headerlink" title="若干数最小公倍数思路"></a>若干数最小公倍数思路</h2><p>我们求几个数的最小公倍数，最简单的方法当然是把这几个数直接相乘。但是我们要求的是最小公倍数，相乘得到的不一定是最小公倍数，数与数之间可能还有约数，相乘的结果与最小公倍数的差别可能就是多乘了一个两个约数。如果我们所有的约数都除掉的话是不是就是最小的公倍数了呢。</p><p>答案是肯定的，这就是为什么我们需要用到 <em>欧几里得算法</em>。</p><p>所以很容易地我有了第一个想法，就是先把所有结果都相乘然后再除以所有数的最大公约数。这个想法被验证是错误的，我们我得到的是相乘的结果不是相加的结果，不应该除以所有数的最大公因数，相乘所有数与数之间的公约数都会乘进去。</p><p>第二个想法就是，我对这个数组遍历，然后对每一个数除以它前面所有数的最大公约数，得到一个新的数组，我把新数组中的所有数都乘起来，就是这几个数的最小公倍数了。这个方法是先把公约数去除掉，然后在相乘。相较于之前的方法在算法的复杂度上可能有所降低。</p><p>是的这个方法没有证明，我也无从知晓别处是否有这样的方法，我判断它是否有效的办法就是先用代码来实现它。对我来说这确实是一个没有被证明的算法，希望各位看观能够提提意见，如有错误还请指正。</p><h2 id="具体JavaScript实现"><a href="#具体JavaScript实现" class="headerlink" title="具体JavaScript实现"></a>具体JavaScript实现</h2><p>接下来还请看我的代码实现。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">smallestCommons</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gcd</span>(<span class="params">p,q</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(q===<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> gcd(q,p%q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">            arr[j] = arr[i]/gcd(arr[i],arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">x,y</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x*y;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是我实现的代码，如果有错误，欢迎在评论区指正，谢谢！</p><hr><p>参考链接：</p><p><a href="https://www.w3cschool.cn/codecamp/smallest-common-multiple.html" target="_blank" rel="noopener">最小公倍数算法挑战</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于&quot;&gt;&lt;a href=&quot;#关于&quot; class=&quot;headerlink&quot; title=&quot;关于&quot;&gt;&lt;/a&gt;关于&lt;/h2&gt;&lt;p&gt;假设有这么一道题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;求给定任意个整数的最小公倍数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;s
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.kingr.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.kingr.top/tags/JavaScript/"/>
    
      <category term="Algorithm" scheme="http://www.kingr.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript原型继承的方式探讨</title>
    <link href="http://www.kingr.top/2019/02/18/jsObjInherit/"/>
    <id>http://www.kingr.top/2019/02/18/jsObjInherit/</id>
    <published>2019-02-18T09:21:13.000Z</published>
    <updated>2019-02-19T11:18:44.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>基于类和子类的继承方式是我们在别的语言如<code>python</code>、<code>Java</code>和<code>C++</code>中接触到最多的一种模式，这种模式无论是对于创建子类还是创建对象来说都是十分方便的。<code>JavaScript</code>算是一个特例吧，它的基于原型链的方式很容易将人们搞的迷糊，对于很多接触过<code>class</code>继承方法的人来说都是很难接受的一个事情，其中就包括我，我也是花了较长的一个时间才接受摸清这个事情。</p><p>虽然说基于原型链来实现面向对象编程的<code>JavaScript</code>在代码上有一些混乱，但是如果我们认真琢磨还是不难发现其中的有迹可循的真相。以下是我对<code>JavaScript</code>原型继承的方式的一个终结，适合已经了解了一些<code>JavaScript</code>面向对象编程的童鞋阅读，如果有错误欢迎指正。</p><h2 id="原型继承方式"><a href="#原型继承方式" class="headerlink" title="原型继承方式"></a>原型继承方式</h2><p><code>JavaScript</code>的标准一直在更新，新的标准出来也不是所有的厂商和浏览器都能够跟上，所以这就造成了一部分混乱，JS面向对象课程的内容有老的有新的，但没有全的。这也是我在学习中遇到的困境。对于<code>JavaScript</code>原型继承的方式，我个人总结主要有以下集中。</p><ul><li>基于<code>Object.create()</code>方式</li><li>使用<code>new</code>关键字</li><li>使用桥接函数</li><li><code>class</code>关键字</li></ul><h3 id="基于Object-create-方式"><a href="#基于Object-create-方式" class="headerlink" title="基于Object.create()方式"></a>基于<code>Object.create()</code>方式</h3><p>这个方法是<code>ES6</code>标准新出的，所以使用的时候需要注意支持与否的问题。</p><p>假设我们有一个<code>Student</code>对象，有一个<code>name</code>属性，有一个<code>hello</code>方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = props.name || <span class="string">"Unamed"</span>;</span><br><span class="line">&#125; </span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">"Hello "</span> + <span class="keyword">this</span>.name + <span class="string">"!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想要创建一个新的对象小学生<code>PrimaryStudent</code>继承自<code>Student</code>，使用<code>Object.create()</code>方法我们需要这么做<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">Student.call(<span class="keyword">this</span>,props);</span><br><span class="line">&#125;</span><br><span class="line">PrimaryStudent.prototype = <span class="built_in">Object</span>.create(Student.prototype);</span><br><span class="line">PrimaryStudent.prototype.constructor = PrimaryStudent;  <span class="comment">//因为我们重写了PrimaryStudent的原型所以我们需要重新改回它的构造函数</span></span><br><span class="line"><span class="keyword">var</span> xiaohua = <span class="keyword">new</span> PrimaryStudent(&#123;<span class="attr">name</span>:<span class="string">"xiaohua"</span>&#125;);</span><br></pre></td></tr></table></figure></p><p>这个时候我们看看<code>xiaohua</code>的原型链是不是符合我们的要求</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xiaohua ---&gt; PrimaryStudent.prototype ---&gt; Student.prototype ---&gt;<span class="built_in">Object</span>.prototype ---&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>从这个原型链我们就可以看出<code>PrimaryStudent</code>确实是继承自<code>Student</code>的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xiaohua.name; <span class="comment">//”xiaohua“</span></span><br><span class="line">xiaohua.hello(); <span class="comment">//”Hello xiaohua!“</span></span><br></pre></td></tr></table></figure><h3 id="使用new关键字"><a href="#使用new关键字" class="headerlink" title="使用new关键字"></a>使用<code>new</code>关键字</h3><p>准确说这种方法和上面的方法本质上是一模一样的，区别在在于我们把<code>PrimaryStudent.prototype = Object.create(Student.prototype);</code>这一行替换为了<code>PrimaryStudent.prototype = new Student({})</code>，其他的代码是一样的。</p><p>这两种方法在原型链上都是一样的，调用起来也可以达到一样的效果。</p><p>但是我们注意到一个问题，使用这种方式的时候我们不得不在<code>Student()</code>中加上参数，因为这是该构造函数所必须要求的，这种导致一个问题，我们的<code>PrimaryStudent.prototype</code>的属性中多了一个<code>name</code>，冗杂的属性，这并不是我们所需要的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">PrimaryStudent.prototype.hasOwnProperty(<span class="string">"name"</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>我们可以使用接下来的方法来修复。</p><h3 id="使用桥接函数"><a href="#使用桥接函数" class="headerlink" title="使用桥接函数"></a>使用桥接函数</h3><p>使用桥接函数的方法来自<code>JSON</code>的发明者道格拉斯，我觉得这个方法是上一个方法的改进，桥接函数的核心是空函数<code>F()</code>，创建一个空函数<code>F</code>之后，令<code>F.prototype = Student.prototype</code>，然后再从<code>F</code>上创建新对象并赋值给<code>PrimaryStudent.prototype</code>，最后再对<code>PrimaryStudent</code>的构造函数进行修正。据此我们得到的<code>PrimaryStudent</code>确实是继承自<code>Student</code>的，并且没有属性上的冗余。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = props.name || <span class="string">'Unnamed'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    Student.call(<span class="keyword">this</span>,props);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">F.prototype = Student.prototype;</span><br><span class="line">PrimaryStudent.prototype = <span class="keyword">new</span> F();</span><br><span class="line">PrimaryStudent.prototype.constructor = PrimaryStudent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaohua = <span class="keyword">new</span> PrimaryStudent(&#123;<span class="attr">name</span>:<span class="string">"xiaohua"</span>&#125;);</span><br></pre></td></tr></table></figure><p>道格拉斯这个方法可以说是很机智了，我们且来看看<code>xiaohua</code>的原型链：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">xiaohua ---&gt; PrimaryStudent.prototype ---&gt; Student.prototype ---&gt; <span class="built_in">Object</span>.prototype ---&gt; <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>符合我们的要求并且<code>PrimaryStudent</code>中没有冗余的属性。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">PrimaryStudent.prototype.hasOwnProperty(<span class="string">"name"</span>);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>我们发现这个继承的方法可以复用，所以我们可以写以用于继承的函数，专门用来连接“子”与“父”，在此我们却不来实现了，可以在参考链接找一找哦</p><h3 id="Class继承"><a href="#Class继承" class="headerlink" title="Class继承"></a>Class继承</h3><p>这种方式可谓是最贴近真实，子类与父类是我们在学习其他语言经常就能接触到的，使用这种方式完成继承的关系，是我们更容易接受的一件事情。但是<code>JavaScript</code>并没有实现真正的<code>Class</code>的概念，现实仍然是<code>Class</code>包装下的原型链，所以我们还是有必要学习Class出现之前的继承方式，更有利于我们理解<code>JavaScript</code>原型链的概念。</p><p><code>Class</code>关键字是ES6标准新定义的，所以我们在使用的时候也还是要考虑到兼容性问题。</p><p>使用<code>Class</code>定义一个<code>Student</code>：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Class Student()&#123;</span><br><span class="line"><span class="keyword">constructor</span>(props)&#123;</span><br><span class="line"><span class="keyword">this</span>.name = props.name;</span><br><span class="line">&#125;</span><br><span class="line">hello() &#123;</span><br><span class="line">alert(<span class="string">"Hello "</span>+ <span class="keyword">this</span>.name + <span class="string">"!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用<code>Class</code>定义一个<code>PrimaryStudent</code>继承自<code>Student</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Class PrimaryStudent extends Student()&#123;</span><br><span class="line"><span class="keyword">constructor</span>(props)&#123;</span><br><span class="line"><span class="keyword">super</span>(props);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Class</code>的方法简直不能太好用！！！</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>以上便是我个人在学习过程中总结出来的一些JavaScript的继承的方式，希望能够帮到你，更希望你能够在评论区提出一些意见，感谢观看！</p><p><strong>参考链接：</strong></p><ul><li><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014344997013405abfb7f0e1904a04ba6898a384b1e925000" target="_blank" rel="noopener">廖雪峰的JavaScript教程</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">Object.create()用法</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于&quot;&gt;&lt;a href=&quot;#关于&quot; class=&quot;headerlink&quot; title=&quot;关于&quot;&gt;&lt;/a&gt;关于&lt;/h2&gt;&lt;p&gt;基于类和子类的继承方式是我们在别的语言如&lt;code&gt;python&lt;/code&gt;、&lt;code&gt;Java&lt;/code&gt;和&lt;code&gt;C++&lt;/c
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.kingr.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.kingr.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>使用JavaScript来判断质数</title>
    <link href="http://www.kingr.top/2018/12/17/prime-number-javascript/"/>
    <id>http://www.kingr.top/2018/12/17/prime-number-javascript/</id>
    <published>2018-12-17T04:50:32.000Z</published>
    <updated>2018-12-17T05:20:56.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><p>使用<code>JavaScript</code>判断一个数是否为质数<br>质数即是除了他本身更和<code>1</code>这两个公约数之外没有别的公约数的数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>&apos;use strict&apos;;function priN(x){    if (x &lt; 2) return false;    else        for(i=2;i*i&lt;=x;i++){            if(x%i===0) return false;        }return true;}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用的方法即是从<code>2</code> 开始遍历，直到遍历完所有可能的情况为止。如果找到了公约数则返回<code>false</code>，否则返回<code>true</code> 。</p><p><strong>这里有一个值得注意的点是我们的遍历结束点是 <code>i*i&lt;=x</code></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于&quot;&gt;&lt;a href=&quot;#关于&quot; class=&quot;headerlink&quot; title=&quot;关于&quot;&gt;&lt;/a&gt;关于&lt;/h2&gt;&lt;p&gt;使用&lt;code&gt;JavaScript&lt;/code&gt;判断一个数是否为质数&lt;br&gt;质数即是除了他本身更和&lt;code&gt;1&lt;/code&gt;这两个公约数
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.kingr.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.kingr.top/tags/JavaScript/"/>
    
      <category term="Algorithm" scheme="http://www.kingr.top/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Python播放MP3 总结</title>
    <link href="http://www.kingr.top/2018/11/15/python-play-mp3/"/>
    <id>http://www.kingr.top/2018/11/15/python-play-mp3/</id>
    <published>2018-11-15T06:15:08.000Z</published>
    <updated>2018-11-15T07:51:22.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><p>最近在做一个项目，需要在树莓派中使用到python来播放MP3文件，树莓派这个设备比较特殊，不像是我们库和驱动都比较齐全的电脑，里面很多东西都是精简化的。所以使用各种各样的库的过程中我总结了一下自己的经验。</p><p>如何使用python播放MP3文件。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>花了大量的时间来进行测试，最终整理出以下的方法：</p><ul><li>playsound</li><li>mp3play</li><li>pygame</li><li>pyglet</li><li>pyaudio</li><li>python-vlc</li><li>subprocess &amp; mpg123</li></ul><h2 id="playsound"><a href="#playsound" class="headerlink" title="playsound"></a>playsound</h2><p>playsound 在我的Linux的电脑上工作正常而且工作良好。使用方法也是非常简单，</p><ol><li>使用 <code>`</code>pip3 install playsound` 来进行安装</li><li><p>代码简单</p><pre><code>import playsound playsound.playsound(&apos;/path/to/your/mp3file&apos;)</code></pre></li><li><p><code>playsound</code> 的文档：<a href="https://pypi.org/project/playsound/" target="_blank" rel="noopener">playsound</a></p></li></ol><p>但是<code>playsound</code> 在我的树莓派上却无论如何也跑不起来，程序执行完毕也没有错误提示，弃之。</p><h2 id="mp3play"><a href="#mp3play" class="headerlink" title="mp3play"></a>mp3play</h2><p><code>mp3play</code> 在我的Linux电脑上甚至都没有跑起来，原因是它支持python2或者别的什么原因</p><ol><li>使用 <code>pip install mp3play</code> 进行安装</li><li><p>代码示例</p><pre><code>import mp3playfilename = r&apos;C:\Documents and Settings\Michael\Desktop\music.mp3&apos;clip = mp3play.load(filename)clip.play()</code></pre></li><li><p><code>mp3play</code> 参考文档：<a href="https://pypi.org/project/mp3play/" target="_blank" rel="noopener">mp3play</a> </p></li></ol><p>在树莓派上同样跑不起来，弃之</p><h2 id="pygame"><a href="#pygame" class="headerlink" title="pygame"></a>pygame</h2><p><code>pygame</code> 相较于前两者来说是一个大型的东西，它有更多的用处，但是我只想用它来播放一个mp3，没有在我的电脑上进行测试，直接在树莓派上测试成功。</p><ol><li>使用<code>pip3 install pygame</code> 来进行安装</li><li><p>代码示例</p><pre><code>from pygame import mixer mixer.init()mixer.music.load(&apos;/path/to/your/mp3file&apos;)mixer.music.play()</code></pre></li><li><p><code>pygame</code> 参考文档：<a href="https://www.pygame.org/docs/" target="_blank" rel="noopener">pygame</a> </p></li></ol><p><code>pygame</code> 虽然在树莓派上一次性测试成功，但是播放出来的音频却是语速失调的音频，人说话的声音听起来就像是萝莉音，弃之。</p><h2 id="pyglet"><a href="#pyglet" class="headerlink" title="pyglet"></a>pyglet</h2><p><code>pyglet</code> 和<code>pygame</code>是一个级别的，但是就播放音频来说它的使用明显又复杂许多。 在树莓派上的使用失败。</p><ol><li>使用 <code>pip3 install pyglet</code> 来进行安装</li><li><p>代码示例</p><pre><code>import pygletfrom pyglet.gl import *pyglet.options[&apos;audio&apos;] = (&apos;openal&apos;, &apos;directsound&apos;, &apos;silent&apos;)music = pyglet.resource.media(&apos;music.mp3&apos;)music.play()pyglet.app.run()</code></pre></li><li><p><code>pyglet</code> 参考文档：<a href="https://pyglet.readthedocs.io/en/pyglet-1.3-maintenance/programming_guide/media.html" target="_blank" rel="noopener">pyglet</a><br><code>pylet</code> 虽然看起来专业很多但是对于我的项目的使用来说就很复杂，在树莓派上测试失败，弃之。在使用<code>pyglet</code>的过程中遇到一个问题在树莓派上似乎没有办法解决，那就是提示<code>AVbin</code>的相关问题，要么缺失，要么就是其他的。在树莓派上无论是下在稳定的还是最新的版本的<code>AVbin</code>都无法解决这个问题。一些相关的文档贴在这里希望能帮到各位：</p></li></ol><p><a href="http://avbin.github.io/AVbin/Download.html" target="_blank" rel="noopener">AVbin Downloads</a><br><a href="https://stackoverflow.com/questions/10302873/python-pyglet-avbin-how-to-install-avbin" target="_blank" rel="noopener">Install AVbin</a> </p><h2 id="pyaudio"><a href="#pyaudio" class="headerlink" title="pyaudio"></a>pyaudio</h2><p><code>pyaudio</code> 使用似乎还要进行一些巧妙的设置才能进行正常的播放，我没有对它进行测试</p><ol><li>使用 <code>pip3 install pyaudio</code> 来进行安装</li><li><code>pyaudio</code> 官方的文档：<a href="http://people.csail.mit.edu/hubert/pyaudio/" target="_blank" rel="noopener">pyaudo</a></li></ol><h2 id="python-vlc"><a href="#python-vlc" class="headerlink" title="python-vlc"></a>python-vlc</h2><p><code>python-vlc</code> 是VLC 的python接口库其github地址为<a href="https://github.com/oaubert/python-vlc" target="_blank" rel="noopener">python-vlc</a> ，该库的使用需要调用VLC的库，理论上是可以播放vlc支持的媒体文件。但是在我单薄的树莓派上就测试失败了。进过多次测试并解决了一些些问题，但是失败了。</p><ol><li>使用<code>pip3 install python-vlc</code> 来进行安装，没有VLC还需要安装VLC：树莓派上<code>sudo apt-get install vlc</code></li><li><p>代码示例</p><pre><code>import vlc p = vlc.MediaPlayer(&apos;/path/to/your/mp3file&apos;)p.play()</code></pre></li><li><p><code>python-vlc</code> 的文档：<a href="https://wiki.videolan.org/PythonBinding" target="_blank" rel="noopener">python-vlc</a></p></li></ol><p>使用<code>python-vlc</code>来播放mp3从代码上看是十分简单的，但是还需要在树莓派中安装vlc的，依赖许多，很容易撞见各种问题，弃之。</p><h2 id="subprocess-amp-mpg123"><a href="#subprocess-amp-mpg123" class="headerlink" title="subprocess &amp; mpg123"></a>subprocess &amp; mpg123</h2><p><code>subprocess</code> 并不是一个直接播放音频的库，使用它来调用系统软件来播放音频，代码十分简单，音调语速上也是正常的。</p><ol><li>使用 <code>sudo apt-get install mpg123</code> </li><li><p>代码示例</p><pre><code>import subprocesssubprocess.Popen([&apos;mpg123&apos;, &apos;-q&apos;, &apos;/path/to/your/mp3file&apos;]).wait()</code></pre></li><li><p>参考文档：<a href="https://docs.python.org/3/library/subprocess.html" target="_blank" rel="noopener">subprocess</a> </p></li></ol><p>这个方法或许是最为简单的方法了，依赖少，代码简洁，易于控制。在树莓派上一次试验就成功了。</p><hr><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://stackoverflow.com/questions/20021457/playing-mp3-song-on-python" target="_blank" rel="noopener">play mp3 on python</a></p><p><a href="https://stackoverflow.com/questions/26673746/playing-mp3-files-with-pyaudio" target="_blank" rel="noopener">play mp3 with pyaudio</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于&quot;&gt;&lt;a href=&quot;#关于&quot; class=&quot;headerlink&quot; title=&quot;关于&quot;&gt;&lt;/a&gt;关于&lt;/h1&gt;&lt;p&gt;最近在做一个项目，需要在树莓派中使用到python来播放MP3文件，树莓派这个设备比较特殊，不像是我们库和驱动都比较齐全的电脑，里面很多东西
      
    
    </summary>
    
      <category term="Python" scheme="http://www.kingr.top/categories/Python/"/>
    
    
      <category term="python" scheme="http://www.kingr.top/tags/python/"/>
    
      <category term="MP3" scheme="http://www.kingr.top/tags/MP3/"/>
    
  </entry>
  
  <entry>
    <title>dein:deoplete补全只生效一次</title>
    <link href="http://www.kingr.top/2018/11/12/dein-problem/"/>
    <id>http://www.kingr.top/2018/11/12/dein-problem/</id>
    <published>2018-11-12T08:12:33.000Z</published>
    <updated>2018-11-12T12:50:55.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在使用dein作为我的vim插件管理器之后，经常出现一些我无法解决的问题。</p><p>其中一个就是我使用的deoplete做为我的自动补全的插件，但是这个每次只是在我更改完vim配置之后生效一次，然后退出vim重启之后就失效了。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>将<code>```````````````</code>if dein#load_sate()<code></code> 和对应的<code>endif</code> 删除了就好了</p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>对自己所使用的东西不熟悉，没有一步一步来去了解如何使用dein就草草将它应用到我的配置上了。以后应当一步步来。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;在使用dein作为我的vim插件管理器之后，经常出现一些我无法解决的问题。&lt;/p&gt;
&lt;p&gt;其中一个就是我使用的deoplet
      
    
    </summary>
    
      <category term="解决问题" scheme="http://www.kingr.top/categories/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="vim" scheme="http://www.kingr.top/tags/vim/"/>
    
      <category term="deoplete" scheme="http://www.kingr.top/tags/deoplete/"/>
    
  </entry>
  
  <entry>
    <title>arch 不能挂载root(You are now being dropped into an emergency shell)</title>
    <link href="http://www.kingr.top/2018/11/04/arch-cant-mount-root/"/>
    <id>http://www.kingr.top/2018/11/04/arch-cant-mount-root/</id>
    <published>2018-11-04T04:38:23.000Z</published>
    <updated>2018-11-04T05:13:59.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>这两天很高兴的给自己的新t480装上了arch，将以前的数据移植过来之后在里面快乐的玩耍，结果这天忽然之间更新（<code>pacman -Syu</code>）之后，一切都不一样了。电脑开始卡顿，很多应用开始闪退。不久之后，只能看到黑屏。</p><p>然后重启</p><p>然后gg</p><pre><code>mount /new_root: unknown filesystem type &apos;ext4&apos;You are now being dropped into an emergency shell</code></pre><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>和之前安装arch的时候一样，先到Windows刻录一个arch安装硬盘</p><p>然后挂载好root盘和boot盘，<code>arch-chroot</code>进到自己的arch中，然后执行<code>pacman -Syu mkinitcpio systemd-tools linux</code></p><p>命令如下</p><pre><code># mount /dev/sdxY /mnt         #Your root partition.# mount /dev/sdxZ /mnt/boot    #If you use a separate /boot partition.# arch-chroot /mnt# pacman -Syu mkinitcpio systemd-tools linux</code></pre><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>这次出现问题的原因大概是滚动更新滚挂了自己的系统内核。以后更新的时候一定要小心一点，不要在系统不稳定的时候进行更新。</p><p>arch的官方文档是十分有用处的。</p><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://wiki.archlinux.org/index.php/pacman" title="Pacman" target="_blank" rel="noopener">arch pacman 文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;这两天很高兴的给自己的新t480装上了arch，将以前的数据移植过来之后在里面快乐的玩耍，结果这天忽然之间更新（&lt;code&gt;
      
    
    </summary>
    
      <category term="Arch" scheme="http://www.kingr.top/categories/Arch/"/>
    
    
      <category term="arch" scheme="http://www.kingr.top/tags/arch/"/>
    
      <category term="root" scheme="http://www.kingr.top/tags/root/"/>
    
  </entry>
  
  <entry>
    <title>Python版ssr通过链接导入节点</title>
    <link href="http://www.kingr.top/2018/10/08/python-ssr-rss/"/>
    <id>http://www.kingr.top/2018/10/08/python-ssr-rss/</id>
    <published>2018-10-08T10:45:12.000Z</published>
    <updated>2018-10-09T11:10:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><p>很多时候我们都苦于使用python版本的ssr的时候必须自己手动写入配置，所以这一次我们将使用python来进行ssr解析并导入配置。在这一节中我们需要用到许多上一节的内容，所以我建议各位看官，先移步<a href="https://www.kingr.top/2018/10/07/ssr-decode/">ssr和ss链接解密</a></p><p>本节所有代码都可以在我的<a href="https://github.com/kingrongH/shadowsocksr/tree/manyuser/shadowsocks/RSS" target="_blank" rel="noopener">github</a>中找到。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>首先我们需要知道ssr或者ss的链接是怎样加密的，在前一节中我们解析了ssr链接的加密过程，我们知道了ssr链接是通过<code>Base64</code>的编码方式进行加密的。所以在这一次试验中我们需要用到的主要的库就是<code>base64</code>和<code>re</code>，这两个库一般linux的python环境中都自动安装了，如果你出现了<code>no module nameed ***</code>的问题，那么可以使用<code>pip</code>安装一下。</p><pre><code>import base64import reimport json</code></pre><h1 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h1><p>在上一节中我们使用的在线的<code>Base64</code>解码工具进行解码的，这一次我们需要使用Python的<code>base64</code>这个库，官方使用文档在此：<a href="https://docs.python.org/3/library/base64.html" target="_blank" rel="noopener">Base64官方文档</a>。这个库的使用方式十分简单，我们一般会使用到的是这个库的两个函数：<code>url_safe_base64decode(s)</code>和<code>base64_decode(s)</code>，传入我们需要解码的对象，然后返回的是解码后的<code>byte</code>类型的字符。</p><p>在这里我们需要特别注意的是我们传入的s的长度必须为4的倍数，这一点在上一节中我们实际上已经谈到过了。不再多说直接上代码</p><pre><code>def decoe(s):  num = len(s)%4  if num==0:    s = base64.url_safe_base64decode(s)  else:    s = s + &apos;#&apos;*(4-num)    s = base64.url_safe_base64decode(s)    return s</code></pre><p>这样一个简单的base64 针对url的解码函数就出炉了，因为我们的ssr链接是需要使用在浏览器地址栏的，所以我们需要使用针对url的函数。</p><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>完成了解码函数之后我们需要对我们的ssr链接进行解析了。我们需要得到的是一个由配置组成的字典例如：</p><pre><code>config = {    &quot;server&quot;: &quot;0.0.0.0&quot;,    &quot;server_ipv6&quot;: &quot;::&quot;,    &quot;server_port&quot;: 8388,    &quot;local_address&quot;: &quot;127.0.0.1&quot;,    &quot;local_port&quot;: 1080,    &quot;password&quot;: &quot;m&quot;,    &quot;method&quot;: &quot;aes-128-ctr&quot;,    &quot;protocol&quot;: &quot;auth_aes128_md5&quot;,    &quot;protocol_param&quot;: &quot;&quot;,    &quot;obfs&quot;: &quot;tls1.2_ticket_auth_compatible&quot;,    &quot;obfs_param&quot;: &quot;&quot;}</code></pre><p>利用解码函数我们可以得到我们的每一个参数，然后存入字典中，参照上一节的文档我们需要对这个链接进行多次解码，代码如下：</p><pre><code>def Analyze(s):     config = {    &quot;server&quot;: &quot;0.0.0.0&quot;,    &quot;server_ipv6&quot;: &quot;::&quot;,    &quot;server_port&quot;: 8388,    &quot;local_address&quot;: &quot;127.0.0.1&quot;,    &quot;local_port&quot;: 1080,    &quot;password&quot;: &quot;m&quot;,    &quot;method&quot;: &quot;aes-128-ctr&quot;,    &quot;protocol&quot;: &quot;auth_aes128_md5&quot;,    &quot;protocol_param&quot;: &quot;&quot;,    &quot;obfs&quot;: &quot;tls1.2_ticket_auth_compatible&quot;,    &quot;obfs_param&quot;: &quot;&quot;  }  #第一次解码  s = decode(s)  spilted = re.spilt(&apos;:&apos;,s)  #将多个参数分离开来  pass_param = spilted[5]  pass_param_spilted = re.spilt(&apos;\/\?&apos;,pass_param)  passwd = decode(pass_param_spilted[0]) #解码得到password  #匹配param、remarks和group  try:    obfs_param = re.search(r&apos;obfsparam=([^&amp;]+)&apos;,pass_param_spilted[1]).group[1]  except:    obfs_param=&quot;&quot;  try:    protocol_param = re.search(r&apos;protoparam=([^&amp;]+)&apos;, pass_param_spilted[1])    protocol_param = decode(protocol_param)  except:    protocol_param = &apos;&apos;  try:    remarks = re.search(r&apos;remarks=([^&amp;]+)&apos;, pass_param_spilted[1]).group(1)    remarks = decode(remarks)  except:    remarks = &apos;&apos;  try:    group = re.search(r&apos;group=([^&amp;]+)&apos;, pass_param_spilted[1]).group(1)    group = decode(group)  except:    group = &apos;&apos;    #将各个值赋值入字典中  config[&apos;server&apos;] = spilted[0]  config[&apos;server_port&apos;] = int(spilted[1])  config[&apos;password&apos;] = passwd  config[&apos;method&apos;] = spilted[3]  config[&apos;protocol&apos;] = spilted[2]  config[&apos;obfs&apos;] = spilted[4]  config[&apos;protocol_param&apos;] = protocol_param  config[&apos;obfs_param&apos;] = obfs_param  return [config,group,remarks]</code></pre><p>这些代码大致还原了我们在上一节中使用在线工具解析的过程，其中我们可以看见，在匹配参数的过程中我们一直在使用<code>try...except...</code>，这是因为并不是所有的ssr链接中都包含了这些信息，如果不包含，我们就可以将它赋值为空文本。</p><h1 id="保存配置"><a href="#保存配置" class="headerlink" title="保存配置"></a>保存配置</h1><p>在python版本的ssr的使用中我们一般是使用<code>python local.py -c ***.json -d start</code> 命令来完成ssr的启动的。所以我们为了便捷和进一步开发的需要需要将我们的配置保存为<code>*.json</code>，使用<code>json</code>库，<a href="https://docs.python.org/3/library/json.html" target="_blank" rel="noopener">官方文档</a></p><pre><code>def save_as_json(d,name=&apos;conf&apos;):  #直接调用解析函数  [data_dict,group,remarks] = Analyze(d)  json_str = json.dumps(data_dict)  #保存在config目录下  with open(&apos;config/&apos;+naem+&apos;.json&apos;,&apos;w&apos;) as f:    json.dump(data_dict,f)</code></pre><h1 id="综合利用"><a href="#综合利用" class="headerlink" title="综合利用"></a>综合利用</h1><p>我们直接使用在终端输入的方式来获取ssr链接，然后进一步进行解析保存到相应的目录下，这里需要注意一点就是我们的所有使用的ssr code 都是去除了<code>ssr://</code>前缀的。</p><pre><code>if __name__ == &quot;__main__&quot;:  ssr = input(&apos;ssr link:&apos;)  code = ssr[6:]  name = input(&apos;config name:&apos;)  try:      save_as_json(code,name)      print(&quot;Successful:please check config at \&apos;config/\&apos;&quot;)  except:      print(&quot;Error:Fail to save config!&quot;)</code></pre><h1 id="更进一步"><a href="#更进一步" class="headerlink" title="更进一步"></a>更进一步</h1><p>将这一切做好之后，我们将获得一个可以通过ssr链接导入节点配置的程序，然而在使用过程中还是稍显麻烦，我觉得主要有以下几点值得进一步地探索：</p><ul><li>文件的名字还是自定义的，能不能通过我们获得的group和remarks信息完成对保存的名字和文件夹的自动设定呢</li><li>能不能进一步完成ssr的订阅功能呢，像其他客户端一样。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于&quot;&gt;&lt;a href=&quot;#关于&quot; class=&quot;headerlink&quot; title=&quot;关于&quot;&gt;&lt;/a&gt;关于&lt;/h1&gt;&lt;p&gt;很多时候我们都苦于使用python版本的ssr的时候必须自己手动写入配置，所以这一次我们将使用python来进行ssr解析并导入配置。在这一
      
    
    </summary>
    
      <category term="Shadowsocksr" scheme="http://www.kingr.top/categories/Shadowsocksr/"/>
    
    
      <category term="shadowsocksr" scheme="http://www.kingr.top/tags/shadowsocksr/"/>
    
      <category term="shadowsocks" scheme="http://www.kingr.top/tags/shadowsocks/"/>
    
      <category term="翻越长城" scheme="http://www.kingr.top/tags/%E7%BF%BB%E8%B6%8A%E9%95%BF%E5%9F%8E/"/>
    
  </entry>
  
  <entry>
    <title>ssr和ss链接解码(decode)</title>
    <link href="http://www.kingr.top/2018/10/07/ssr-decode/"/>
    <id>http://www.kingr.top/2018/10/07/ssr-decode/</id>
    <published>2018-10-07T00:48:01.000Z</published>
    <updated>2018-10-07T02:14:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><p>我们所熟知的翻墙工具<code>Shadowsocksr</code>和<code>Shadowocks</code>都有可以直接通过链接导入节点配置的功能。那么它们到底是怎么从ssr或者ss链接的一堆乱码中提取出节点信息的呢？</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>实际上无论是<code>ssr</code>或者<code>ss</code>链接都是，经过多次<code>[Base64](https://zh.wikipedia.org/wiki/Base64 ’Base64‘)</code>编码方式进行加密的，这种加密方式无法起到真正的加密的效果，正所谓<code>防君子不防小人</code>。</p><p>由于Base64解码后含有<code>+</code>、<code>/</code>等url敏感字符所以在针对url的Base64编码中，会将<code>/</code>改为<code>_</code>，将<code>+</code>改为<code>-</code>。Base64所解码的字符个数必须是4的倍数，不足四的倍数的需要在字符末尾添加<code>#</code>补全为4的倍数。</p><p><code>ssr</code> 的编码方式就是采用针对url的Base64编码(UrlBase64Encode)的，在解码过程中我发现，ssr加密前的格式是</p><pre><code>server:server_port:protocol:method:obfs:password/?obfsparam=obfs_param&amp;protoparam=protocol_param&amp;remarks=remarks&amp;group=group</code></pre><p>其中<code>password</code>及之后的<code>obfs_param</code>等参数都需要进一步的解码的，并且<code>obfs_param</code>及之后的参数在不同的节点中可能是非必须的。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>本次测试采用<a href="https://doub.io/sszhfx/" target="_blank" rel="noopener">逗比根据地</a>分享的免费帐号。测试工具采用<a href="http://tool.oschina.net/encrypt?type=3" target="_blank" rel="noopener">开源中国在线工具</a>。链接如下：</p><pre><code>ssr://NDUuNjIuMjM4LjE0Nzo1NjA1OmF1dGhfc2hhMV92NDpjaGFjaGEyMDp0bHMxLjJfdGlja2V0X2F1dGg6Wkc5MVlpNXBieTl6YzNwb1puZ3ZLalUyTURVLz9yZW1hcmtzPTVweXM1WVdONkxTNTZMU201WS0zNXAybDZJZXFPbVJ2ZFdJdWFXOHZjM042YUdaNEx3</code></pre><p>去除<code>ssr://</code>前缀之后，解码结果如下</p><pre><code>45.62.238.147:5605:auth_sha1_v4:chacha20:tls1.2_ticket_auth:ZG91Yi5pby9zc3poZngvKjU2MDU/?remarks=5pys5YWN6LS56LSm5Y-35p2l6IeqOmRvdWIuaW8vc3N6aGZ4Lw</code></pre><p><img src="https://i.loli.net/2018/10/07/5bb96788bf5a7.png" alt="ssr_decode1.png" title="ssr decode"></p><p>这里不包含混淆参数和协议参数等，我们只需要对<code>password</code>和<code>remarks</code>进行单独解码：</p><p>  <img src="https://i.loli.net/2018/10/07/5bb96884374a5.png" alt="password" title="password"></p><p>  <img src="https://i.loli.net/2018/10/07/5bb968f07d86d.png" alt="remarks" title="remarks"></p><p>其中我们可以注意到<code>remarks</code>这一项中包含一个<code>-</code>，我们需要将它改成<code>+</code>才能解码成功。</p><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><p>在linux环境下使用python 版本ssr翻越长城的方式是十分不方便的，我们还是得必须自己将节点配置添加到json文件中，有没有可能像windows、ios等其他客户端一样通过ssr链接导入节点配置呢。</p><p>在下一节中我们将使用python来实现这个代码。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于&quot;&gt;&lt;a href=&quot;#关于&quot; class=&quot;headerlink&quot; title=&quot;关于&quot;&gt;&lt;/a&gt;关于&lt;/h1&gt;&lt;p&gt;我们所熟知的翻墙工具&lt;code&gt;Shadowsocksr&lt;/code&gt;和&lt;code&gt;Shadowocks&lt;/code&gt;都有可以直接通过链接导
      
    
    </summary>
    
      <category term="Shadowsocksr" scheme="http://www.kingr.top/categories/Shadowsocksr/"/>
    
    
      <category term="shadowsocksr" scheme="http://www.kingr.top/tags/shadowsocksr/"/>
    
      <category term="shadowsocks" scheme="http://www.kingr.top/tags/shadowsocks/"/>
    
      <category term="翻越长城" scheme="http://www.kingr.top/tags/%E7%BF%BB%E8%B6%8A%E9%95%BF%E5%9F%8E/"/>
    
  </entry>
  
  <entry>
    <title>树莓派(raspberry pi) ssh RefuseConnection</title>
    <link href="http://www.kingr.top/2018/09/29/raspberrypiRefuseConnection/"/>
    <id>http://www.kingr.top/2018/09/29/raspberrypiRefuseConnection/</id>
    <published>2018-09-29T06:37:36.000Z</published>
    <updated>2018-10-04T09:04:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>通过ssh连接树莓派的时候，出现如下问题：</p><pre><code>ssh: connect to host xxx.xxx.xx.x port 22: connection refused.</code></pre><p>这个时候意味着你的ip是正确的，但是树莓派系统中的<code>ssh</code>却并没有开启。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>这个时候我们只需要将内存卡拔下了，插入电脑中，在 <code>boot</code> 分区创建一个名字为 <code>ssh</code> 的新文件夹。重新插回设备，启动，问题解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;通过ssh连接树莓派的时候，出现如下问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh: connect to host xxx.
      
    
    </summary>
    
      <category term="解决问题" scheme="http://www.kingr.top/categories/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="树莓派" scheme="http://www.kingr.top/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
      <category term="ssh" scheme="http://www.kingr.top/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>labelImg安装使用</title>
    <link href="http://www.kingr.top/2018/09/24/labelImg%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.kingr.top/2018/09/24/labelImg安装使用/</id>
    <published>2018-09-24T13:58:09.000Z</published>
    <updated>2018-09-27T10:25:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="why"><a href="#why" class="headerlink" title="why"></a>why</h1><p>因为我们在学习和使用tensorflow或者其他机器学习的框架的时候，我们最终还是会需要把自己配置的数据使用到我们的程序中，这个时候我们需要一个能够帮助自己为图片贴标签的工具。labelImg正是这样一个简易好用的工具。</p><p><a href="https://github.com/tzutalin/labelImg" title="labelImg" target="_blank" rel="noopener">labelImg</a></p><p><img src="https://i.loli.net/2018/09/24/5ba8ef101801f.png" alt="labelImg" title="labelImg"></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>我们安装的前提是我们的电脑是必须有pyhton、qt4或者qt5、lxml。</p><pre><code>git clone https://github.com/tzutalin/labelImg.git</code></pre><p>然后进入到<code>labelImg</code>目录下</p><pre><code>make qt5py3 #如果是pyqt4则 `make qt4py2`</code></pre><p>最终执行</p><pre><code>python3 labelImg.py</code></pre><p>我们就来到了我们可以操作的图形界面了，然后可以自由的贴标签了。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>该工具本来就是设计了图形化的界面，所以对于它的使用也十分简单明了的。</p><p>前提：</p><ul><li>一个很多图片的文件夹</li><li>一个和上一个文件夹并行的文件夹，用来存储标签</li></ul><p>使用</p><h2 id="步骤-PascalVOC"><a href="#步骤-PascalVOC" class="headerlink" title="步骤(PascalVOC)"></a>步骤(PascalVOC)</h2><ol><li>点击<code>Change Save Dir</code> 将默认的标签存储文件改变至之前已经建好的标签文件夹，如图</li></ol><p><img src="https://i.loli.net/2018/09/27/5baca9550cf3c.png" alt="Screenshot_20180927_175430.png"></p><ol start="2"><li><p><code>Open Dir</code>打开你将要贴标签的图片的目录，选择完毕后会自动加载第一张图片。</p></li><li><p>右键图片选择<code>CreateRectBox</code>或者在菜单中选择<code>CreateRectBox</code>,选择出你所需要贴标签的部分。<code>Ctrl+S</code>或者点击<code>Save</code>将会自动将标签信息保存到刚刚设置到的目录下。</p></li></ol><p><img src="https://i.loli.net/2018/09/27/5bacabb516d5c.png" alt="Screenshot_20180927_180617.png"></p><h2 id="步骤-YOLO"><a href="#步骤-YOLO" class="headerlink" title="步骤(YOLO)"></a>步骤(YOLO)</h2><ol><li><p>通过点击左边菜单里的<code>PascalVOC</code>转换为<code>YOLO</code>格式</p></li><li><p>在你的创建的<code>label</code>文件夹下编辑<code>class.text</code>，定义你将要贴的所有标签。</p></li></ol><p><img src="https://i.loli.net/2018/09/27/5bacaed592f66.png" alt="Screenshot_20180927_181929.png"></p><ol start="3"><li>按照上一个步骤，选框和贴贴标签。</li></ol><p>因为贴标签过程中需要一张一张执行，所以快速的方法是合理利用快捷键和<code>default label</code>,祝你使用愉快！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;why&quot;&gt;&lt;a href=&quot;#why&quot; class=&quot;headerlink&quot; title=&quot;why&quot;&gt;&lt;/a&gt;why&lt;/h1&gt;&lt;p&gt;因为我们在学习和使用tensorflow或者其他机器学习的框架的时候，我们最终还是会需要把自己配置的数据使用到我们的程序中，这个时候
      
    
    </summary>
    
      <category term="学习" scheme="http://www.kingr.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python" scheme="http://www.kingr.top/tags/python/"/>
    
      <category term="tensorflow" scheme="http://www.kingr.top/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>python-opencv调用摄像头</title>
    <link href="http://www.kingr.top/2018/09/12/python-opencv%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4/"/>
    <id>http://www.kingr.top/2018/09/12/python-opencv调用摄像头/</id>
    <published>2018-09-12T08:40:08.000Z</published>
    <updated>2018-09-12T09:41:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><p>Python利用opencv的库实现对摄像头的数据的读取，并逐帧显示。</p><p>opencv的安装： 终端运行 <code>pip install python-opencv</code> 即可。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="用到的库"><a href="#用到的库" class="headerlink" title="用到的库"></a>用到的库</h2><pre><code>import cv2import numpy as np #如果你需要对读取到的摄像数据进行进一步的应用。</code></pre><h2 id="调用摄像头"><a href="#调用摄像头" class="headerlink" title="调用摄像头"></a>调用摄像头</h2><p>调用摄像头，<code>VideoCapture()</code> 内的数字表示的是摄像头的设备编号，笔记本内建摄像头的编号一般为 <code>0</code>，如果你想使用外置摄像头将数字改为 <code>1</code>等，随你的摄像头的设备编号决定，可以通过设备管理器查看并尝试。</p><pre><code>cap = cv2.VideoCapture(0)</code></pre><h2 id="读取并播放"><a href="#读取并播放" class="headerlink" title="读取并播放"></a>读取并播放</h2><p>在 <code>while</code> 循环中利用 <code>cap.read()</code> 读取摄像头的某一帧，通过 <code>imshow()</code> 来展示这一帧。等待1个单位时间后，如果检测到 <code>q</code> 按键被按下，就跳出循环，即停止读取和展示。</p><p>其中 <code>ret</code> 变量是<code>cap</code>读取之后返回的一个<code>bool</code> 变量，可以用它来判断是否读取到数据。</p><pre><code>while(True):  ret,frame = cap.read(0) #读取数据  cv2.imshow(&apos;Frame&apos;,frame) #展示结果  if cv2.waitkey(1) &amp; 0xFF == ord(&apos;q&apos;):    break</code></pre><h2 id="释放摄像头"><a href="#释放摄像头" class="headerlink" title="释放摄像头"></a>释放摄像头</h2><p>在调用摄像头之后不要忘记释放摄像头，否则你的下次调用摄像头的时候可能会有被占用的报错。我们需要释放摄像头并关闭我们用来展示的窗口。</p><pre><code>cap.release()cv2.destoryAllWindows()</code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>附上上述操作的完整代码：</p><pre><code>import numpy as np  import cv2cap = cv2.VideoCapture(0)while(True):    ret, frame = cap.read()    cv2.imshow(&apos;Frame&apos;,frame)    if cv2.waitKey(1) &amp; 0xFF == ord(&apos;q&apos;):        breakcap.release()cv2.destroyAllWindows()</code></pre><h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><h2 id="保存视频或者截图"><a href="#保存视频或者截图" class="headerlink" title="保存视频或者截图"></a>保存视频或者截图</h2><p>如果我们想要保存其中的某一帧，即截图，使用 <code>cv2.imwrite()</code> 可以非常方便的完成该功能，<code>imwrite</code>的使用方法，戳 <a href="https://docs.opencv.org/3.0-beta/modules/imgcodecs/doc/reading_and_writing_images.html?highlight=imwrite#cv2.imwrite" title="imwrite" target="_blank" rel="noopener">这里</a></p><p>对于保存视频需要稍微复杂一些些的操作，我们需要创建一个 <code>VideoWrite</code>对象，并指定保存的文件名，然后指定<code>Fourcc</code> 值(下节详细)。然后指定每秒的帧数(fps)和帧的大小。该对象的最后一个参数为<code>isColor</code>，如果为<code>True</code>则编码器需要彩色帧，默认为 <code>False</code>,即保存为灰度帧。</p><p><strong>Fourcc</strong>是用于指定<strong>视频编码器</strong>的四字节代码，在 <a href="http://www.fourcc.org/codecs.php" target="_blank" rel="noopener">fourcc.org</a> 中可以找到可用的编码器列表（值得注意的是对于不同的系统适用的编码器似乎还不同） 。在这里我们使用 <code>cv2.VideoWriter_fourcc()</code> 对象来指定，比如使用 <code>cv2.VideoWriter_fourcc(* &#39;XVID&#39;)</code> 来指定<code>XVID</code>编码器。</p><p>代码如下：</p><pre><code>import numpy as npimport cv2cap = cv2.VideoCapture(0)fourcc = cv2.VideoWriter_fourcc(*&apos;XVID&apos;)out = cv2.VideoWriter(&apos;output.avi&apos;,fourcc, 20.0, (640,480))while(cap.isOpened()):    ret, frame = cap.read()    if ret==True:        frame = cv2.flip(frame,0)        out.write(frame)        cv2.imshow(&apos;frame&apos;,frame)        if cv2.waitKey(1) &amp; 0xFF == ord(&apos;q&apos;):            break    else:        breakcap.release()out.release()cv2.destroyAllWindows()</code></pre><h1 id="相关来源"><a href="#相关来源" class="headerlink" title="相关来源"></a>相关来源</h1><p><a href="https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_gui/py_video_display/py_video_display.html" title="Opencv" target="_blank" rel="noopener">Opencv</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于&quot;&gt;&lt;a href=&quot;#关于&quot; class=&quot;headerlink&quot; title=&quot;关于&quot;&gt;&lt;/a&gt;关于&lt;/h1&gt;&lt;p&gt;Python利用opencv的库实现对摄像头的数据的读取，并逐帧显示。&lt;/p&gt;
&lt;p&gt;opencv的安装： 终端运行 &lt;code&gt;pip i
      
    
    </summary>
    
      <category term="学习" scheme="http://www.kingr.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python" scheme="http://www.kingr.top/tags/python/"/>
    
      <category term="opencv" scheme="http://www.kingr.top/tags/opencv/"/>
    
  </entry>
  
</feed>
